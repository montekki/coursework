\begin{comment}
\section {Особенности реализации} 

\subsection{Описание подсистемы utrace-uprobes}

\bigskip
Как было сказано ранее, система utrace-uprobes используется 
для определения "попадания" на контрольные точки.
При этом utrace предоставляет средства создания 
отладчиков в виде модулей ядра, в то время, как 
uprobes использует utrace для расставления точек 
останова в теле процесса и наблюдения за попаданием 
исполнения на них. 
Рассмотрим особенности использования этой системы 
более подробно.
Как было сказано выше, utrace является подсистемой 
ядра, позволяющей создавать отладчики, работающие в 
пространстве ядра в виде модулей. При этом, модуль 
должен реализовать некоторые функции-обработчики 
событий, происходящих в отлаживаемом приложении. 

Пример:

\bigskip
\begin{lstlisting}
u32 (*report_syscall_entry)(struct utrace_attached_engine *engine,
				struct task_struct *tsk,
				struct pt_regs *regs);

\end{lstlisting}

\bigskip
Как только отлаживаемый процесс совершит системный вызов, будет вызвана 
соответствующая функция отлаживаемого движка - {\texttt report\_sysc
all\_entry()} (разумеется, если она была зарегистрирована). Вызов 
данного обработчика происходит до выполнения системного вызова, 
отладчик может безопасно получать доступ к остановленному отлаживаемому 
процессу. Функция-обработчик возвращает битовую маску, которая определяет, что 
должно произойти далее~--- можно изменять состояние отладки, 
прекращать отладку, скрывать событие от других отладочных 
движков и многое другое. 

Отладочный движок регистрируется следующей функцией: 
\bigskip
\begin{lstlisting}
struct utrace_attached_engine *
    utrace_attach(struct task_struct *target, int flags,
	      	  const struct utrace_engine_ops *ops, 
		  unsigned long data);
  
\end{lstlisting}

\bigskip 
Данный вызов ассоциирует отладочный движок к указанным процессом. 
Возможна регистрация более чем одного отладочного движка для 
одного и того же процесса~--- серьезное отличие от ptrace(). 
Только что зарегистрированный движок ничего не делает и 
находится в состоянии idle. Для запуска необходимо указать 
соответствующие флаги в вызове функции 

\bigskip
\begin{lstlisting}
int utrace_set_flags(struct task_struct *target,
			 struct utrace_attached_engine *engine,
			 unsigned long flags);

\end{lstlisting}

\bigskip 
Существует специальный флаг - {\texttt UTRACE\_EVENT(QUIESCE)}, 
который может переключать процесс в состояние ожидания. В общем 
случае, все операции с процессом в первую очередь требуют 
установки этого флага, после чего можно ожидать исполнения 
коллбека {\texttt report\_quiesce()}, который извещает об 
остановке процесса. Есть множество других событий, извещения 
о которых могут быть получены отладочным движком. В их числе 
fork(), exec(), получение сигнала, завершение процесса, вызов 
системного вызова и др..

\bigskip
{\bfseries Uprobes.}

\bigskip
Uprobes является клиентом системы utrace и входит в состав утилит для 
наблюдения за событиями в системе Systemtap в качестве модуля ядра. 
Кроме этого, существуют патчи, позволяющие интегрировать uprobes 
непосредственно в ядро Linux. Основной функцией данного набора функций 
является обеспечение возможности проставления контрольных точек в код 
отлаживаемого процесса и регистрация функций, обрабатывающих события, 
связанные с данными точками. Есть два типа таких контрольных точек: 
uprobes и uretprobes. Uprobe может быть установлена на любой адрес в 
виртуальном адресном пространстве процесса и сработает при попадании 
исполнения на инструкцию, расположенную по этому адресу. Uretprobe 
сработает при завершении работы указанной функции в отлаживаемом 
процессе. При регистрации точки останова, uprobes сохраняет копию 
инструкции, расположенной по этому адресу в приложении, останавливает 
его исполнение, подменяет первые байты по этому адресу на инструкцию 
точки останова (int3 на i386 x86\_64) и вновь запускает исполняемое 
приложение. Когда исполнение попадает на эту инструкцию, срабатывает 
ловушка и генерируестя сигнал SIGTRAP. Uprobes получает этот сигнал и 
находит связанную с ним точку останова и ее функцию-обработчик. 
Отлаживаемый процесс будет остановлен до завершения работы 
функции-обработчика. После завершения работы функции-обработчика uprobes 
исполняет сохраненную команду, которая первоначально располагалась 
по адресу точки останова в пользовательском процессе и вновь запускает 
пользовательский процесс.   

Регистрация контрольной точки может быть произведена с помощью функции
 

\bigskip 
\begin{lstlisting}
#include <linux/uprobes.h>
int register_uprobe(struct uprobe *u); 
\end{lstlisting}

Будет установлена точка останова в виртуальном адресном пространстве 
процесса u->pid по адресу u->vaddr и с обработчиком v->handler, который
 может быть определен следующим образом: 

\begin{lstlisting}
#include <linux/uprobes.h>
#include <linux/ptrace.h>
	void handler(struct uprobe *u, struct pt_regs *regs);
\end{lstlisting}

\bigskip
При завершении отлаживаемого процесса, либо при вызове функции exec() 
uprobes автоматически удаляет все контрольные точки и их обработчики. 
При выполнении вызова fork() во вновь созданном процессе удаляются все 
контрольные точки. 

\bigskip
\subsection{Архитектура SELinux и ее изменения.}

Рассмотрим более подробно архитектуру SELinux, существующую 
систему динамической смены контекста и изменения, которые были 
в нее внесены. 

Итак, как уже было сказано, в SELinux три атрибута безопасности: 
идентификатор пользователя, роль и тип вместе образуют так называемый 
контекст безопасности. SELinux хранит контексты безопасности в своих 
таблицах, каждая запись в которых определяется идентификатором 
безопасности, (SID), который представляет собой целочисленную 
переменную. Разным контекстам ставятся в соответствие разные 
идентификаторы безопасности. При этом Security Server принимает все 
решения, описанные в логике политики на основании двух идентификаторов 
взаимодействующих объектов. 

SELinux состоит из следующих основных компонент:
\begin{itemize}
\item Код в ядре (Security Server, hooks,selinuxfs)
\item Библиотека для взаимодействия с ядром
\item Политика безопасности
\item Различные инструменты
\item Размеченные файловые системы
\end{itemize}

\bigskip
{\bfseries Код в ядре}

Задачей SELinux в ядре является наблюдение за событиями в системе и 
принятие решений о разрешении о различных операциях в соответствии с 
политикой безопасности. Кроме этого, Security Server ведет логи для 
определенных разрешенных или запрещенных операций, список которых 
описан в политике. Кроме этого Security Server заполняет соответствующие 
структуры безопасности в запускаемых приложениях. Такой структурой 
является следующая структура: 

\bigskip 
\begin{lstlisting}
	
struct task_security_struct {
	u32 osid;		
	u32 sid;	
	u32 exec_sid;		
	u32 create_sid;		
	u32 keycreate_sid;	
	u32 sockcreate_sid;	
};

\end{lstlisting}

\bigskip
На нее указывает поле security в структуре task\_struct. Поля 
структуры безопасности включают в себя следующую информацию: 

\begin{tabular}{|p{3cm}|p{9cm}|}
\hline 
\ttfamily Поле 
& 
Описание \\ 
\hline
osid
& 
Старый идентификатор, который был у процесса, до выполнения execve. \\

\hline
sid
& 
Текущий идентификатор \\
\hline
exec-sid
&
Идентификатор, использующийся для определения прав на выполнение exec.
 \\
\hline
create\_sid 
&
Идентификатор, которым будут помечены объекты ФС, создаваемые данным пр
оцессом \\
\hline
keycreate\_sid
& 
Идентификатор, который будет присвоен ? \\ 
\hline
sockcreate\_sid  
&
Идентификатор для сокетов данного процесса. \\ 
\hline
\end {tabular}

\bigskip
В нашем случае интересно поле sid. Именно на основании значения 
данного поля в Security Server принимаются решения согласно логике политики 
SELinux. 

\bigskip
{\bfseries Библиотка работы с интерфейсами SELinux} 
Данная библиотека (libselinux.so) используется большинством из 
компонент SELinux, находящихся в пользовательском пространстве.

\bigskip
{\bfseries Политика безопасности SELinux} 
Сервер безопасности принмает все свои решения на основании политики 
безопасности, описанной администратором системы. При запуске системы 
SELinux загружает политику безопасности из бинарного файла, который, 
как правило находится в /etc/security/selinux. 

{\bfseries Динамическое переключение контекстов в SELinux} 

Как уже упоминалось выше, в SELinux существует 
метод динамического переключения контекста. 
Рассмотрим его более подробно. 
Данная система предполагает, что приложение должно быть тесно 
интегрировано с существующей политикой и в зависимости 
от своего текущего состояния сообщать SELinux о смене 
контекста. Такой подход позволил бы создавать более 
безопасные приложения, при разработке которых возможно
было бы выделять состояния, в которых приложению нужны
различные минимальные права. Такими интерфейсами стали 
функции 

\bigskip 
\begin{lstlisting} 
#include <selinux/selinux.h>

	int getcon(security_context_t *context);
	int getprevcon(security_context_t *context);
	int getpidcon(pid_t pid, security_context_t *context);
	int getpeercon(int fd, security_context_t *context);
	int setcon(security_context_t context);
\end{lstlisting}

\bigskip 
Основной целью данной системы является предоставление 
возможности доверенному приложению изменять свои права
непосредственно в процессе исполнения, отказываясь от 
определенных прав, когда они не нужны и запрашивая 
некоторые права, когда в них есть необходимость. 

Эта система появилась несмотря на то, что основной 
идеологией безопасного программирования с участием 
SELinux является разбиение приложения на некоторое 
количество меньших приложений, за поведением которых
гораздо легче наблюдать, при этом 
у каждого из них могут быть различные права. Причиной
создания системы стал тот факт, что многие приложения
по тем или иным причинам не могут быть спроектированы
таким образом.

Данная система реализована следующим образом. 
Упомянутые выше функции пишут контекст безопасности, который
является строкой символов, в /proc/PID/attr/current. 
Для того, чтобы приложение могло использовать указанные
функции в политике для него должно быть описано 
соответствующее разрешение, которое выглядит следующим 
образом:

\bigskip
\begin{lstlisting}
allow XXX_t self:process setcurrent
\end{lstlisting}

\bigskip
Но данное предложение, по сути, всего лишь разрешает
приложению использовать интерфейсы динамического изменения 
типа, никак не определяя, в какой контекст может перейти 
приложение. За это отвечает предложение следующего вида: 

\bigskip
\begin{lstlisting}
allow XXX_t YYY_t:process dyntransition
\end{lstlisting}

\bigskip
Важно отметить, что логика работы Security Server в 
данном случае такова, что решения относительно возможности
приложения динамически менять свой домен на указанный
принимаются независимо от смены домена при вызове exec*. 

Рассмотрим, что происходит в ядре при динамической смене
контекста приложения. Как уже было сказано, SELinux 
использует набор интерфейсов LSM. При записи в указанный 
выше интерфейс /proc/PID/attr/current, цепляется функция
security\_setprocattr(), которая производит определенные 
проверки на основании политики, и в том случае, если 
в политике описана возможность такого изменения контекста, 
производится все необходимые действия. Важной особенностью
является тот факт, что такие изменения невозможны для 
многопоточных приложений. Это является весьма логичным 
ограничением, так как множество нитей одного процесса 
используют одно и то же пространство памяти и гарантировать
реальное разделение данных невозможно. 

SELinux реализует функцию LSM security\_setprocattr()
методом selinux\_setprocattr(). 

\bigskip 
\begin{lstlisting}
static int selinux_setprocattr(struct task_struct *p,
	char *name, void *value, size_t size)
\end{lstlisting}

\bigskip
Аргументами этой функции является процесс, смену 
контекста которого нужно произвести, опция того, что 
в контексте нужно менять (поля в структуре task\_security\_ struct ),
сам контекст в своем строковом представлении, и 
длина строки представления контекста. В первую очередь
проверяется, что тот процесс, в котором происходят изменения~---
текущий процесс. Далее проверяется возможность процесса менять
указанное поле в своей структуре безопасности. После этого 
функция ставит целочисленный идентификатор безопасности в 
соответствие строковому представлению контекста. После этого 
проверяется возможность смены контекста на указанный и 
в случае, если это возможно, текущий идентификатор безопасности 
в структуре процесса меняется на полученный из строкового 
представления процесса. 

{\bfseries Изменения в коде ядра}
Особенностью реализации LSM является то, 
что доступ к реализации методов безопасности 
имеет лишь код ядра, они не экспортируются для 
модулей. При этом есть некоторые функции, 
которые экспортируются из SELinux, они описаны 
в файле ./linux/security/selinux/exports.c. 
Предлагается перенести реализацию методов
изменения контекста и получения информации 
о контексте приложения из selinux/hooks.c в 
сам сервер безопасности в selinux/ss/services.c
и экспортировать их в ядро из exports.c. При этом
вместо функций, реализующих реакцию на запись 
в интерфейсы /proc/PID/ в hooks.c предлагается 
заменить заглушками, которые ничего не делают. 
Действительно, отсутствует необходимость в 
двух механизмах смены доменов приложений, 
кроме этого, было бы правильно полностью 
убрать получение информации об изменении 
доменов от самих пользовательских приложений
из ядра. Таким образом в exports.c появятся две 
новые функции 

\bigskip 
\begin{lstlisting}
int selinux_kern_getprocattr(struct task_struct *p,
		char *name,char **value)
{
	if (selinux_enabled)
		return security_kern_getprocattr(p,name,value);
	else {
		*value = NULL;
		return 0;
	}
}
EXPORT_SYMBOL_GPL(selinux_kern_getprocattr);

int selinux_kern_setprocattr(struct task_struct *p, 
		char *name, void *value, size_t size)
{
	if (selinux_enabled)
		return security_kern_setprocattr(p,name,value,size);
	else {
		value = NULL;
		return 0;
	}
}
EXPORT_SYMBOL_GPL(selinux_kern_setprocattr);
\end{lstlisting} 

\bigskip 
Данные функции позволяют получать и 
изменять контекст приложения из модуля. 

\bigskip 
{\bfseries Конфигурационный файл для модуля} 

Конфигурационный файл, из которого модуль ядра должен получать 
информацию об адресах точек останова и изменениях контекстов 
безопасности имеет простую структуру. Он содержит структуры данных: 

\bigskip 
\begin{lstlisting} 
typedef struct dyntran_info {
	uint32_t ssid;
	uint32_t tsid; 
	long 	 bpt;
}dyntran_info_t;
\end{lstlisting}

\bigskip
Преимущества создания такого бинарного файла в следующем: 
в ядро попадает информация уже в той форме, в которой 
ее удобно представлять и осуществлять все необходимые 
манипуляции. В противном же случае приходилось бы при загрузке
файла, содержащего символьную информацию производить 
массу операций связанных с определением наличия указанных
контекстов в политике. При работе модуля приходилось бы 
постоянно производить приведение целочисленных идентификаторов
к их строковому представлению и обратно. 

Получить целочисленное представление контекста 
безопасности из строкового можно при помощи 
функции 
\begin{lstlisting}
#include <sepol/policydb/services.h>

int sepol_context_to_sid(const sepol_security_context_t scontext,/*IN*/
		 size_t scontext_len,    /* IN */
		 sepol_security_id_t * out_sid); /* OUT */
\end{lstlisting}

\bigskip

Используя лексический и синтаксический разбор 
строится бинарный файл с указанной структурой. 
При этом, данная утилита тесно интегрируется 
с политикой. Стоит отметить, что создание 
конфигурационного файла, отдельного от политики
позволяет применять все изменения в нем прямо 
на ходу, без пересборки основной политики и без
перезагрузки системы. В ряде случаев это помогает 
экономить время и не останавливать работу системы.

\bigskip
Проведем несколько тестов компилятора конфигурационных
данных. Рассмотрим его на следующем файле, который 
содержит некоторую информацию о двух изменениях 
типов. 

\bigskip
\begin{lstlisting}
system_u:system_r:kernel_t system_u:object_r:security_t 080456AA
system_u:object_r:fs_t     system_u:object_r:file_t     0804234B
\end{lstlisting}

\bigskip
Если запустить в отладочном режиме 
checkpolicy и проверить идентификаторы,
соответствующие данным строковым контекстам, 
мы обнаружим, что они равны 1,2,4 и 5. Дадим 
на вход нашему модулю данный файл. На выходе 
получим (с отладочными комментариями)

\begin{lstlisting}
Got token:system_u:system_r:kernel_t
The sid of the token is: 1
Got token:system_u:object_r:security_t
The sid of the token is: 2
Got token:080456AA
The address of the bpt is 134502058
Got token:system_u:object_r:fs_t
The sid of the token is: 4
Got token:system_u:object_r:file_t
The sid of the token is: 5
Got token:0804234B
The address of the bpt is 134488907
\end{lstlisting}

\bigskip
Очевидно, что транслятор работает 
правильно. Заметим, что он должен статически
связываться с libsepol~--- библиотекой 
работы с бинарными файлами политик. 

\end{comment}
