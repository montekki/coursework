
\bigskip 
\subsection{Существующий в SELinux метод динамического 
переключения контекста} 

В 2004-м году в SELinux началась работа над системой 
интерфейсов для пользовательских приложений, позволяющих
приложениям динамически изменять свой контекст. Данная 
система предполагает, что приложение должно быть тесно 
интегрировано с существующей политикой и в зависимости 
от своего текущего состояния сообщать SELinux о смене 
контекста. Такой подход позволил бы создавать более 
безопасные приложения, при разработке которых возможно
было бы выделять состония, в которых приложению нужны
различные минимальные права. Такими интерфейсами стали 
функции 

\bigskip 
\begin{lstlisting} 
#include <selinux/selinux.h>

	int getcon(security_context_t *context);

	int getprevcon(security_context_t *context);

	int getpidcon(pid_t pid, security_context_t *context);

	int getpeercon(int fd, security_context_t *context);

	int setcon(security_context_t context);
\end{lstlisting}

\bigskip 
Логика работы системы динамических изменений контекстов. 

Основной целью данной системы является предоставление 
возможности доверенному приложению изменять свои права
непосредственно в процессе выполнения, отказываясь от 
определенных прав, когда они не нужны и запрашивая 
некоторые права, когда в них есть необходимость. 

Эта система появилась несмотря на то, что основной 
идеологией безопасного программирования с участием 
SELinux является разбиение приложения на некоторое 
количество меньших приложений, за поведением которых
гораздо легче наблюдать, при этом, в общем случае 
у каждого из них могут быть различные права. Причиной
создания системы стал тот факт, что многие приложения
по тем или иным причинам не могут быть спроектированы
таким образом.

Данная система реализована следующим образом. 
Данные функции пишут контекст безопасности, который
является строкой символов, в /proc/PID/attr/current. 
Для того, чтобы приложение могло использовать указанные
функции в политике для него должно быть описано 
соответствующее разрешение, которое выглядит следующим 
образом:

\bigskip
\begin{lstlisting}
allow XXX_t self:process setcurrent
\end{lstlisting}

\bigskip
Но данное предложение, по сути, всего лишь разрешает
приложению использовать интерфейсы динамического изменения 
типа, никак не определяя, в какой контекст может перейти 
приложение. За это отвечает предложение следующего вида: 

\bigskip
\begin{lstlisting}
allow XXX_t YYY_t:process dyntransition
\end{lstlisting}

\bigskip
Важно отметить, что логика работы Security Server в 
данном случае такова, что решения относительно возможности
приложения динамически менять свой домен на указанный
принимаются независимо от смены домена при вызове exec*. 

\bigskip
Рассмотрим, что происходит в ядре при динамической смене
контекста приложения. Как уже было сказано, SELinux 
использует набор интерфейсов LSM. При записи в указанный 
выше интерфейс /proc/PID/attr/current, цепляется функция
security\_setprocattr(), которая производит определенные 
проверки на основании политики, и в том случае, если 
в политике описана возможность такого изменения контекста, 
производится все необходимые действия. Важной особенностью
является тот факт, что такие изменения невозможны для 
многопоточных приложений. Это является весьма логичным 
ограничением, так как множество нитей одного процесса 
используют одно и то же пространство памяти и гарантировать
реальное разделение данных невозможно. 

Рассмотрим более детально механизм смены контекста
приложения. SELinux реализует функцию LSM security\_setprocattr()
методом selinux\_setprocattr(). 

\bigskip 
\begin{lstlisting}
static int selinux_setprocattr(struct task_struct *p,
	char *name, void *value, size_t size)
\end{lstlisting}

\bigskip
Аргументами этой функции является процесс, смену 
контекста которого нужно произвести, опция того, что 
в контексте нужно менять (поля в стркутуре task\_security\_struct ),
сам контекст в своем строковом представлении, и 
длина строки представления контекста. В первую очередь
проверяется, что тот процесс, в котором происходят изменения~---
текущий процесс. Далее проверяется возможность процесса менять
указанное поле в своей структуре безопасности. После этого 
функция ставит целочисленный идентификатор безопасности в 
соответствие строковому представлению контекста. После этого 
проверяется возможность смены контекста на указанный и 
в случае, если это возможно, текущий идентификатор безопасности 
в структуре процесса меняется на полученный из строкового 
представления процесса. 

\bigskip
{\bfseries Недостатки данного подхода.} 

Основным недостатком данного подхода является необходимость
внедрять вызовы интерфейсов динамического изменения контекста
непосредственно в приложение. Это влечет за собой сразу 
несколько серьезных проблем. Во-первых, маловероятно, что 
разработчики будут делать это самостоятельно, тем более, 
что у них получится корректно выделить те участки кода, 
на которых приложению нужны различные привилегии, и 
корректно определить необходимые контексты. В таком случае, 
для обеспечения возможности использования этого метода, 
приложение должны изменять третьи разработчики, следовательно, 
такие приложения будут отличны от основной ветки и патчи 
вместе с пересборкой придется осуществлять при выходе 
каждого очередного релиза приложения. Но более 
серьезной проблемой является то, что информация передается 
непосредственно из пользовательского пространства в ядро. 
В данном случае на стороне ядра невозможно определить, 
был ли сделан данный вызов в ходе нормального хода 
выполнения приложения, либо злоумышленник изменил нормальный
ход выполнения и выполнил данный вызов с целью повышения 
прав.
