\section{Пример приложения, использующего 
		динамическую смену прав при смене состояний}
\bigskip 

В своей архитектуре некоторые приложения, 
для которых важен высокий уровень защищенности 
используют идею динамического изменения прав
во время исполнения. В качестве примера можно 
привести архитектуру проекта OpenSSH. OpenSSH
включает в себя сетевое приложение sshd, 
предоставляющее удаленные защищенные пользовательские 
сессии. Для обслуживания каждой пользовательской сессии
в sshd порождается отдельный процесс. При этом, 
можно рассматривать два внутренних состояния такого 
процесса: до и после успешной авторизации пользователя.
До успешной авторизации пользователя процессу, работающему 
с данной пользовательской сессией не являются необходимыми 
права на запуск любых приложений. Поэтому разработчиками 
sshd было принято решение вынести процедуру обработки 
пользовательского ввода в отдельный процесс, 
работающий с минимальными привилегиями и изменяющего 
свою корневую директорию на пустую. С помощью этого 
исключается возможность успешной атаки на sshd даже 
в случае наличия уязвимостей в реализации процедуры 
авторизации пользователя. 

Таким образом, в архитектуре OpenSSH заложена 
идея работы различных частей одного приложения 
с различными минимальными привилегиями. Подобная 
архитектура направленная на повышение защищенности 
приложения предполагает наличие глубоких знаний 
в области информационной безопасности у разработчиков
и существенно большего объема работы.


\section{Решение задачи}

\subsection{Выделение некоторого набора адресов 
		контрольных точек из программы}
\bigskip

Контрольной точкой является некоторый адрес 
в виртуальном адресном пространстве процесса.
Попадание исполнения на контрольную точку 
сигнализирует наблюдающей системе об изменении 
внутреннего состояния наблюдаемого процесса. 

Ставится задача определения адресов контрольных точек 
в наблюдаемом процессе. 

В работе прошлого года предполагалось выделение 
контрольных точек при наличии исходных тексов 
наблюдаемого приложения на языках C/C++ и
информации о том, 
с какими параметрами приложение было собрано.
На этапе подготовки экспертом расставляются 
контрольные точки в исходных текстах приложения. 
При сборке адреса данных контрольных точек 
компонуются в отдельную секцию в исполняемом 
файле приложения. 

Данные адреса связываются с определенной информацией 
в текстовом формате, которая описывается в конфигурационном файле.
Информация, описанная в конфигурационном файле 
определяет работу наблюдающей системы.

В этом году было решено добавить возможность работы 
без необходимости в исходных текстах наблюдаемого 
приложения, а также без необходимости пересборки 
и добавления новой секции с адресами в исполняемый 
файл приложения.

Данный подход позволяет расширить класс приложений, 
наблюдение за поведением которых возможно, до всех 
приложений, работающих в нативном коде. Кроме этого, 
наличие исходных текстов наблюдаемых приложений 
перестает быть необходимым условием.

\subsection{О еще одном подходе к разделению внутренних пространств 
		состояний приложения}
\bigskip 
В работе [14] рассматривается средство автоматизации 
построения нормального поведения приложений при помощи
построения автомата безопасности.  Построение 
состояний автомата реализуется при помощи выделения 
блоков кода, соответствующих различным внутренним 
состояниям приложения. 

Тестирование разработанного средства производилось 
на приложении ftpd со следующим набором команд: 

\begin{itemize}
\item DELE -- удалить файл,
\item HELP -- выводит список команд принимаемых сервером,
\item LIST -- возвращает список файлов,
\item NOOP -- пустая операция,
\item QUIT -- отключиться,
\item SYST -- возвращает тип системы,
\item SHOW -- выдать список файлов с описаниями,
\item DESC -- добавить описание файла,
\item TYPE -- установить тип передачи файла (бинарный, текстовый),
\item STOR -- закачать файл,
\item ABOR -- прервать выполнение команды,
\end{itemize}

Основная особенность данного приложения ~--- наличие 
анонимных и авторизованных пользователей. Действия, 
которые разрешено выполнять этим группам пользователей
различаются. 

На рисунке приведен граф потока управления рассматриваемого 
приложения. 

\begin{figure}
 %\centering
  \scalebox{.35}{\input{miniftp_controlflow1.tex}}
  \scalebox{.35}{\input{miniftp_controlflow2.tex}}
\caption{Свертка и выделение блоков. Демонстрация шагов алгоритма}
\end{figure}


Итоговое разбиение. Блок 10 соответствует операциям, 
которые может производить анонимный пользовател, 
9 соответствует тем операциям, которые может производить 
авторизованный пользователь.

\begin{figure}
\centering
\scalebox{.80}{\input{finalresult.tex}}
\caption{Итоговое разбиение} 
%\label{fig:finalres} 
\end{figure}


На основании полученного разбиения код приложения размечается
контрольными точками. Контрольная точка ставится на входе 
в каждый блок и на выходе из него. Далее работа с этими 
контрольными точками и связанной с ними информацией о смене 
контекстов производится в описанном ниже режиме.

\subsection{Реализация системы контроля поведения
		наблюдаемого приложения}
\bigskip

Результатом работы прошлого года стали изменения в 
ядре Linux, позволяющие динамически переключать
контексты приложения. Изменения были внесены в ядро
версии 2.6.26. Также было предложено использовать 
подсистемы utrace и uprobes для простановки контрольных 
точек в наблюдаемом приложении. 

В этом году был реализован модуль ядра, позволяющий
динамическую смену конеткста безопасности приложения 
при прохождении исполнения через контрольные точки. 
В связи с переносом всего решения на ядро версии 
2.6.32 возникла необходимость полностью переделать 
работу проделанную в прошлом году. Реализацию 
указанного модуля можно разделить на две составляющие. 

Первой из них является использование систем uprobes и 
utrace для расстановки контрольных точек в наблюдаемых 
процессах. Были реализованы списки наблюдаемых процессов,
списки контрольных точек в этих процессах, функции обработчики 
событий происходящих в наблюдаемых процессах. 

Второй частью является полностью переделанная из-за переноса 
на ядро новой версии система поддержки динамических изменений
контекстов SELinux. Эта система используется в реализованном 
модуле для обработки событий перехода процесса в новое состояние,
которые предусматривают смену политики, применяемой к приложению. 

Кроме этого было решено отказаться от модификации синтаксиса 
политик SELinux с целью сделать изменения вносимые в исходную 
систему минимальными. Вместо этого были реализованы интерфейсы 
получения из пользовательского пространства всей необходимой 
информации о наблюдаемых процессах и контрольных точках в них.

\subsection{Выбор уязвимого сетевого приложения}
\bigskip

Для доказательства актуальности разработанного механизма 
контроля и его корректной работы, необходимо продемонстрировать
пример уязвимого приложения, которое является уязвимым 
несмотря на наличие политики SELinux, а реализованное средство 
позволяло бы минимизировать эффект от успешной атаки на данное 
приложение. 

В качестве примера такого приложения был выбран сетевой демон OpenSSH.
OpenSSH является типичным примером приложения, работающего с 
системными правами и с практически полным набором разрещающих прав
SELinux. В том числе, в случае успешной атаки на буфер,
политика SELinux, применяемая к данному приложению не запрещает 
злоумышленнику получить удаленный шелл, сделав вызов system() в 
уязвимом процессе. Это логично, так как демону ssh необходимы права
на вызов функций fork() и exec().

Тем не менее, пример уязвимости в этом приложении должен быть достаточно 
простой для эксплуатации. 

За последнее время в указанном приложении не было обнаружено 
таких уязвимостей, поэтому было решено внести такую уязвимость 
в код приложения вручную. 

В ходе более пристального исследования архитектуры OpenSSH 
оказалось, что разработчики реализовали разбиение приложения
на состояния, обладающие различными правами. Технически 
это осуществляется при помощи порождения новых процессов 
с меньшими привилегиями, которые обрабатывают пользовательский 
ввод, операции с сетью и криптоалгоритмы. Эти новые процессы 
меняют свою корневую директорию на /var/empty делая 
невозможным запуск любых процессов из кода этого дочернего процесса, 
в том числе, в случае успешной атаки на обнаруженные в нем уязвимости. 

Это существенно осложняет реализацию искуственного внесения 
уязвимостей в OpenSSH. Кроме того, описанная выше архитектура
ставит под сомнение сам выбор OpenSSH в качестве требуемого 
примера. Кроме этого, стоит отметить, что множество других 
защитных механизмов, работающих в Linux делают искуственное 
внесение уязвимосте в приложение достаточно сложным процессом. 
В числе таких механизмов можно отметить различные системы защиты 
стека от исполнения и подмены адреса возврата из функции, 
рандомизацию адресного пространства, права чтение, запись и 
исполненье различных секций памяти процесса. 

Из-за указанных технических сложностей на данный момент не удалось 
привести требуемый пример уязвимого приложения.

\subsection{Защита контрольных точек от модификации в процессе 
		выполнения}
\bigskip

При использовании контрольных точек сразу возникает вопрос 
в возможности их модификации и фальсификации злоумышленником.
Контрольная точка реализуется в виде изменения инструкции, 
расположенной по определенному адресу в виртуальном адресном 
пространстве приложения, на инструкцию прерывания.

Возникает вопрос, может ли злоумышленник каким-либо образом 
изменить контрольные точки, расставленные в приложении, 
либо добавить свои собственные, то есть, возможна ли 
ситуация, когда наблюдающая система получает неверные 
данные о поведении приложения. 

Для успешности контроля переходов приложения в новые состояния
мы должны быть уверены в подлинности контрольных точек. 

В реализации работы контрольной точкой является инструкция 
прерывания, записываемая в сегмет кода процесса. Очевидно, что 
сегмент кода не является модифицируемым, что позволяет считать 
контрольные точки надежными. 

Тем не менее, ряд приложений в своей работе используют 
динамическую аллокацию исполнимого кода, что, в общем случае, 
может приводить к размещению исполнимого кода в модифицируемых
областях памяти. Примерами могут служить различные механизмы
использующие just-in-time компиляцию. Следовательно, данный 
вопрос потребует более детального рассмотрения в случае 
расширения набора классов наблюдаемых приложений.

\subsection{Описание подсистемы utrace-uprobes}

\bigskip
Как было сказано ранее, система utrace-uprobes используется 
для определения "попадания" на контрольные точки.
При этом utrace предоставляет средства создания 
отладчиков в виде модулей ядра, в то время, как 
uprobes использует utrace для расставления точек 
останова в теле процесса и наблюдения за попаданием 
исполнения на них. 
Рассмотрим особенности использования этой системы 
более подробно.
Как было сказано выше, utrace является подсистемой 
ядра, позволяющей создавать отладчики, работающие в 
пространстве ядра в виде модулей. При этом, модуль 
должен реализовать некоторые функции-обработчики 
событий, происходящих в отлаживаемом приложении. 

Пример:

\bigskip
\begin{lstlisting}
u32 (*report_syscall_entry)(struct utrace_attached_engine *engine,
				struct task_struct *tsk,
				struct pt_regs *regs);

\end{lstlisting}

\bigskip
Как только отлаживаемый процесс совершит системный вызов, будет вызвана 
соответствующая функция отлаживаемого движка - {\texttt report\_sysc
all\_entry()} (разумеется, если она была зарегистрирована). Вызов 
данного обработчика происходит до выполнения системного вызова, 
отладчик может безопасно получать доступ к остановленному отлаживаемому 
процессу. Функция-обработчик возвращает битовую маску, которая определяет, что 
должно произойти далее~--- можно изменять состояние отладки, 
прекращать отладку, скрывать событие от других отладочных 
движков и многое другое. 

Отладочный движок регистрируется следующей функцией: 
\bigskip
\begin{lstlisting}
struct utrace_attached_engine *
    utrace_attach(struct task_struct *target, int flags,
	      	  const struct utrace_engine_ops *ops, 
		  unsigned long data);
  
\end{lstlisting}

\bigskip 
Данный вызов ассоциирует отладочный движок к указанным процессом. 
Возможна регистрация более чем одного отладочного движка для 
одного и того же процесса~--- серьезное отличие от ptrace(). 
Только что зарегистрированный движок ничего не делает и 
находится в состоянии idle. Для запуска необходимо указать 
соответствующие флаги в вызове функции 

\bigskip
\begin{lstlisting}
int utrace_set_flags(struct task_struct *target,
			 struct utrace_attached_engine *engine,
			 unsigned long flags);

\end{lstlisting}

\bigskip 
Существует специальный флаг - {\texttt UTRACE\_EVENT(QUIESCE)}, 
который может переключать процесс в состояние ожидания. В общем 
случае, все операции с процессом в первую очередь требуют 
установки этого флага, после чего можно ожидать исполнения 
коллбека {\texttt report\_quiesce()}, который извещает об 
остановке процесса. Есть множество других событий, извещения 
о которых могут быть получены отладочным движком. В их числе 
fork(), exec(), получение сигнала, завершение процесса, вызов 
системного вызова и др..

\bigskip
{\bfseries Uprobes.}

\bigskip
Uprobes является клиентом системы utrace и входит в состав утилит для 
наблюдения за событиями в системе Systemtap в качестве модуля ядра. 
Кроме этого, существуют патчи, позволяющие интегрировать uprobes 
непосредственно в ядро Linux. Основной функцией данного набора функций 
является обеспечение возможности проставления контрольных точек в код 
отлаживаемого процесса и регистрация функций, обрабатывающих события, 
связанные с данными точками. Есть два типа таких контрольных точек: 
uprobes и uretprobes. Uprobe может быть установлена на любой адрес в 
виртуальном адресном пространстве процесса и сработает при попадании 
исполнения на инструкцию, расположенную по этому адресу. Uretprobe 
сработает при завершении работы указанной функции в отлаживаемом 
процессе. При регистрации точки останова, uprobes сохраняет копию 
инструкции, расположенной по этому адресу в приложении, останавливает 
его исполнение, подменяет первые байты по этому адресу на инструкцию 
точки останова (int3 на i386 x86\_64) и вновь запускает исполняемое 
приложение. Когда исполнение попадает на эту инструкцию, срабатывает 
ловушка и генерируестя сигнал SIGTRAP. Uprobes получает этот сигнал и 
находит связанную с ним точку останова и ее функцию-обработчик. 
Отлаживаемый процесс будет остановлен до завершения работы 
функции-обработчика. После завершения работы функции-обработчика uprobes 
исполняет сохраненную команду, которая первоначально располагалась 
по адресу точки останова в пользовательском процессе и вновь запускает 
пользовательский процесс.   

Регистрация контрольной точки может быть произведена с помощью функции
 

\bigskip 
\begin{lstlisting}
#include <linux/uprobes.h>
int register_uprobe(struct uprobe *u); 
\end{lstlisting}

Будет установлена точка останова в виртуальном адресном пространстве 
процесса u->pid по адресу u->vaddr и с обработчиком v->handler, который
 может быть определен следующим образом: 

\begin{lstlisting}
#include <linux/uprobes.h>
#include <linux/ptrace.h>
	void handler(struct uprobe *u, struct pt_regs *regs);
\end{lstlisting}

\bigskip
При завершении отлаживаемого процесса, либо при вызове функции exec() 
uprobes автоматически удаляет все контрольные точки и их обработчики. 
При выполнении вызова fork() во вновь созданном процессе удаляются все 
контрольные точки. 


\begin{comment}
\subsection{Схема работы решения}

Работу инфраструктуры поддержки 
контроля состояния приложения можно 
представить в виде последовательности шагов.
\bigskip
\begin{itemize}
\item   Выделение некоторого набора адресов 
	контрольных точек из программы. 	


\item 	Сопоставление информации о контрольных 
	точках информации о смене состояний
	приложения

\item 	Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.
	При этом смена контекста должна происходить
	абсолютно прозрачно для приложения. Это 
	значит, что в том случае, если злоумышленнику
	удается получить контроль над приложением, 
	для изменения его контекста безопасности 
	ему придется воспроизвести нормальный ход
	исполнения этого приложения до смены 
	конекста в какой-либо контрольной точке.  

\end{itemize}  

Рассмотрим эти шаги более подробно. 

Пусть в наличии имеются исходные 
тексты приложения и информация о том, 
как приложение было собрано. 
Изначально, на этапе подготовки, человек
расставляет метки в исходных текстах 
программы. Эти метки являются адресами в 
виртуальном адресном пространстве приложения. 
При помощью метода, описанного в разделе "Реализация 
механизма получения адресов контрольных точек", 
при компиляции приложения попадают 
в отдельную секцию в результирующем 
исполняемом файле. Далее выполняются 
все операции именно с этими метками. 

Имея в наличии адреса в коде и информацию 
о смене состояний, связанную с этими контрольными
точками, 
человеком создается конфигурационный файл, 
формализующий связь между информацией о 
состояниях и контрольными точками. После 
этого данный файл транслируется в специальное 
бинарное представление, подходящее для использования
в модуле контроля за состояниями приложения. Данный 
способ более подробно описывается в подразделе 
"Сопоставление информации о контрольных точках 
информации о смене состояний приложения". 

Во процессе работы программы при помощи 
средства utrace, рассмотренном в разделе 5.1, 
обнаруживаются "попадания" на метки. Данные 
события приводят к смене контекста приложения. 
Смена контекста производится при помощи добавленных 
в ядро функций, которые описаны в разделе "Особенности 
реализации". 

\bigskip 
\subsection{Реализация механизма получения
	адресов контрольных точек.}

Рассмотрим процесс этап подготовки программы 
и получение адресов меток непосредственно из 
бинарного исполняемого файла. 

В данной работе под контрольной точкой 
подразумевается адрес в виртуальном 
адресном пространстве процесса. 
Данные контрольные точки разграничивают
внутренние состояния приложения.  
В первую очередь, возникает необходимость 
некоторым образом разметить код приложения 
контрольными точками, а точнее, получить адреса 
в виртуальном адресном пространстве приложения. 
В данной работе будет рассматриваться только
разметка кода приложений, написанных на C/C++ 
на основании их исходных текстов. Это возможно 
сделать при помощи  расширения GCC, позволяющего
управлять размещением данных в результирующем 
коде приложения. Предлагается при помощи 
этого расширения создавать секцию в бинарном 
исполняемом файле, содержащую адреса 
контрольных точек.

Пример: 

\bigskip
\begin{lstlisting}
#include <stdio.h>
int main (int argn, char *argv[])
{ 
	static void * ret[2] __attribute__((section(".mylabels"),used)) = 
		{&& ret1,&& ret2};
	if (argn > 2) {
	ret1:
		printf("1 n");
	} else {
	ret2:
		printf("2 n");
	}	
	return 0;
}
\end{lstlisting}

\bigskip
В данном примере есть две метки. Можно сказать, что 
здесь они определяют две различные ветви исполнения 
программы. Средства компилятора gcc позволяют управлять 
размещением данных в бинарном файле программы при помощи 
команды \_\_attribute\_\_. При помощи этой команды в исполнимом 
файле возможно создать отдельную секцию, содержащую эти адреса. 
Исполнимые файлы с данной секцией и без нее будут отличаться 
только наличием этой секции, при этом в файле с данной секцией 
все адреса останутся теми же, что и в файле без секции. Таким 
образом мы получаем очень удобный способ хранения адресов прямо 
в бинарном файле программы, откуда их можно извлекать для 
дальнейшей обработки, либо читать эту информацию прямо перед 
запуском приложения. Важно, что в большинстве случаев адреса 
в оптимизированном коде с метками не отличаются от адресов в оптимизированном 
коде без меток. Это было показано в ходе серии экспериментов. 

\bigskip 
\subsection{Связь информации об адресах контрольных точек с изменениями
	контекста приложения} 

Для наблюдения за состояниями приложения и переключения 
контекстов во время исполнения необходимо некоторым образом связать 
информацию об адресах контрольных точек с информацией об
изменениях контекста безопасности приложения, соответствующих
данным контрольным точкам. 

\bigskip
{\bfseries Недостатки данного подхода.} 

Основным недостатком данного подхода является необходимость
внедрять вызовы интерфейсов динамического изменения контекста
непосредственно в приложение. Предлагаемый же подход
предполагает использование немодифицированных приложений.

Это влечет за собой сразу 
несколько серьезных проблем. Во-первых, маловероятно, что 
разработчики будут делать это самостоятельно, тем более, 
что у них получится корректно выделить те участки кода, 
на которых приложению нужны различные привилегии, и 
корректно определить необходимые контексты. В таком случае, 
для обеспечения возможности использования этого метода, 
приложение должны изменять третьи разработчики, следовательно, 
такие приложения будут отличны от основной ветки и патчи 
вместе с пересборкой придется осуществлять при выходе 
каждого очередного релиза приложения. Но более 
серьезной проблемой является то, что информация передается 
непосредственно из пользовательского пространства в ядро. 
В данном случае на стороне ядра невозможно определить, 
был ли сделан данный вызов в ходе нормального хода 
выполнения приложения, либо злоумышленник изменил нормальный
ход выполнения и выполнил данный вызов с целью повышения 
прав.

\bigskip
Предлагается хранить информацию о состояниях 
приложения и контрольных точках в файле, который 
содержал бы необходимую информацию и был бы компактен.
Как уже говорилось ранее, идентификатор безопасности 
целочисленной величиной, которой ставится в соответствие 
символьное представление контекста безопасности. Для 
описания необходимости изменить контекст приложения 
при попадании исполнения на определенный адрес предлагается 
использовать следующую конструкцию: 

\bigskip
\begin{lstlisting}
context_1 context_2 addr
\end{lstlisting}

\bigskip
Данная конструкция будет объявлять, что для приложения
с контекстом context\_1 необходимо произвести смену 
контекста на context\_2 при попадании исполнения на 
инструкцию по адресу addr.
Проблема наблюдения за данными адресами может быть реализована 
по-разному. Можно использовать вызов ptrace и создавать 
сложную систему методов для наблюдения за событиями в 
наблюдаемом приложении. При этом, обязательно нужно 
следить за такими событиями, как fork и exec для определения, 
в какое состояние переходит приложения. Так же наблюдение за exec 
обеспечит определение факта запуска определенного приложения. Такой 
контроль предлагается осуществлять при помощи системы utrace и 
ее клиента~--- uprobes. Utrace является патчем ядра от Red 
Hat, позволяющим строить отладочные движки, работающие в 
пространстве ядра в качестве загружаемых модулей. Uprobes 
является клиентом utrace и позволяет устанавливать точки 
останова на определенные адреса в коде и для каждой из них 
регистрировать функции-обработчики, которые будут срабатывать каждый 
раз, как управление в приложении попадет на одну из точек останова.

\bigskip
\subsection{Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.}

\bigskip
Обычным интерфейсом отладки программ в ОС Linux является 
системный вызов ptrace(). Этот вызов является основой 
для построения отладчиков в пользовательском пространстве. 
Тем не менее, было решено весь механизм наблюдения 
за контрольными точками внести в ядро. Такое решение 
было принято с целью минимизации накладных расходов, 
так как отладка приложений, собранных с отладочной 
информацией ведет к серьезной потере производительности.

Не так давно появилась гораздо более удобная альтернатива 
использованию ptrace для отладки пользовательских 
приложений из пространства ядра в виде utrace~\cite{utrace}. Основной 
код данной системы не имеет интерфейсов в пользовательском 
пространстве. Вместо этого есть интерфейсы в ядре, которые 
позволяют создавать отладочные механизмы, работающие в пространстве 
ядра. Эти интерфейсы основаны на концепции ``отладочного движка'', 
который представляет собой обычную структуру, содержащую 
указатели на функции. У данной структуры есть четырнадцать указателей на
функции, которые будут вызваны в случае определенных событий в 
отлаживаемом приложении. Данная подсистема позволяет отслеживать 
самые разные события в отлаживаемом приложении такие, как системные 
вызовы, сигналы, изменения данных. Клиентом подсистемы utrace 
является uprobes~--- набор функций для расстановки точек
останова в отлаживаемое приложение. Предлагается использовать 
uprobes и utrace для наблюдения за контрольными точками и 
такими событиями, как fork/exec. Далее данная подсистема 
будет описана более подробно. Информацию о точках останова 
и о контекстах модуль будет получать из бинарного файла 
конфигурации. 

\end{comment}
