
\section{Решение задачи разметки исполнимого кода программы контроль
ными точками и контроля за ее состояниями с использованием системы без
опасности уровня ядра SELinux}

\subsection{Постановка задачи} 

Задача контроля текущего состояния приложения требует ввода некоторых 
определений. Определим состояние, как некоторый участок кода программы
, относительно которого может быть принято решение, что для его исполн
ения нужны те или иные минимальные права. Одним из решений задачи конт
роля является патчинг кода программы функциями, которые бы сообщали о 
текущих изменениях состояния приложения. Такой подход не является не у
довлетворительным, так как следствием успешной атаки на приложение мож
ет стать исполнение произвольного кода, который может исполнить одну и
з функций изменения состояний. Другое решение заключается в расстановк
е точек останова на определенные адреса в коде. Контроль должен осущес
твляться из пространства ядра. Этому есть несколько причин: модуль дол
жен вносить некоторые изменения в логику работы SELinux Security Serve
r, кроме этого, мы не можем доверять пользовательскому пространству. К
роме этого, информация о связи между адресами в коде и изменениях сост
ояния приложения должна быть доступна для модуля, осуществляющего конт
роль. Таким образом, можно выделить две основные части работы - реализ
ация механизма контроля за адресами в коде и расширение профилей SELin
ux.

\bigskip 
\subsection{Реализация механизма наблюдения за состояниями процесса.}

Итак, в данной работе под контрольной точкой подразумевается некоторый
 адрес в виртуальном адресном пространстве процесса. Попадание исполне
ния на один из таких адресов, в общем случае, означает изменение состо
яния процесса. В первую очередь, возникает необходимость некоторым обр
азом разметить код приложения контрольными точками, а точнее, получить
 адреса в виртуальном адресном пространстве приложения. В данной работ
е будет рассматриваться только разметка кода приложений, написанных на
 C/C++ на основании их исходных текстов. Это возможно сделать при помо
щи получения адресов меток, которые можно проставлять тех местах кода,
 где предполагается изменение состояния приложения. 

Пример: 

\bigskip
\begin{lstlisting}
#include <stdio.h>
int main (int argn, char *argv[])
{ 
	static void * ret[2] __attribute__((section(".mylabels"),used)) = 
		{&& ret1,&& ret2};
	if (argn > 2) {
	ret1:
		printf("1 n");
	{ else {
	ret2:
		printf("2 n");
	{
	return 0;
{ 
}
\end{lstlisting}
\bigskip
В данном примере есть две метки. Можно сказать, что здесь они определя
ют две различные ветви исполнения программы. Средства компилятора gcc 
позоляют управлять размещением данных в бинарном файле программы при п
омощи команды \_\_attribute\_\_. При помощи этой команды в исполнимом 
файле возможно создать отдельную секцию, содержащую эти адреса. Исполн
имые файлы с данной секией и без нее будут отличаться только наличием 
этой секции, при этом в файле с данной секцией все адреса останутся те
ми же, что и в файле без секции. Таким образом мы получаем очень удобн
ый способ хранения адресов прямо в бинарном файле программы, откуда их
 можно извлекать для дальнейшей обработки, либо читать эту информцию п
рямо перед запуском приложения.

Проблема наблюдения за данными адресами может быть реализована по-разн
ому. Можно использовать вызов ptrace и создавать сложную систему метод
ов для наблюдения за событиями в наблюдаемом приложении. При этом обяз
ательно нужно следить за такими событиями, как fork и exec для определ
ения, в какое состояние переходит приложения. Так же наблюдение за exe
c обеспечит определение факта запуска определенного приложения. Такой 
контроль предлагается осуществлять при помощи системы utrace и ее клие
нта~--- uprobes. Utrace является патчем ядра от Red Hat, позволяющим с
троить отладочные движки, работающие в пространстве ядра в качестве за
гружаемых модулей. Uprobes является клиентом utrace и позволяет устана
вливать точки останова на определенные адреса в коде и для каждой из н
их регистрировать функции-обработчики, которые будут срабатывать ккажд
ый раз, как управление в приложении попадет на одну из точек останова.
 

\bigskip
\subsection{Описание отладочной системы Uprobes-utrace}

\bigskip
Utrace.

\bigskip
Обычным интерфейсом отладки программ под Linux является системный вызо
в ptrace(). Как правило, он используется отладчиками. Данный интерфейс
 очень тяжело использовать, так как приходится создавать целую систему
 методов для разметки точками, наблюдения за событиями и прочих манипу
ляций над отлаживаемым приложением. 

С недавних пор появилась гораздо более удобная альтернатива использова
нию ptrace для отладки пользовательских приложений из пространства ядр
а в виде utrace. Основной код данной системы не имеет интерфейсов в по
льзовательском пространстве. Вместо этого есть интерфейсы в ядре, кото
рые позволяют создавать отладочные механизмы, работающие в пространств
е ядра. Эти интерфейсы основаны на концепции ``отладочного движка'', к
оторый представляет собой обычную структуру, содержащую указатели на ф
ункции. У данной стркутуры есть 14 функций-коллбеков, которые будут вы
званы в случае определенных событий в отлаживаемом приложении. 

\bigskip 
Пример:

\bigskip
\begin{lstlisting}
u32 (*report_syscall_entry)(struct utrace_attached_ engine *engine,
				struct task_struct *tsk,
				struct pt_regs *regs);

\end{lstlisting}

\bigskip
Как только отлаживаемый процесс совершит системный вызов, будет вызван
а соответствующая функция отлаживаемого движка - {\texttt report\_sysc
all\_entry()} (разумеется, если она была зарегистрирована). Вызов данн
ого обработчика происходит до выполнения системного вызова, отладчик м
ожет безопасно полчать доступ к остановленному отлаживаемому процессу.
 Функция-обработчик возвращает битовую маску, которая определяет, что 
должно произойти далее~--- можно изменять состояние отладки, прекращат
ь отладку, скрывать событие от других отладочных движков и многое друг
ое. 

Отладочный движок регистрируется следующей функцией: 
\bigskip
\begin{lstlisting}
struct utrace_attached_engine *
    utrace_attach(struct task_struct *target, int flags,
	      	  const struct utrace_engine_ops *ops, 
		  unsigned long data);
  
\end{lstlisting}

\bigskip 
Данный вызов прицепит отладочный движок к указанному процессу. Возможн
а регистрация более чем одного отладочного движка для одного и того же
 процесса~--- серьезное отличие от ptrace(). Только что зарегистрирова
нный движок ничего не делает и находится в состоянии idle. Для запуска
 необходимо указать соотвествующие флаги в вызове функции 

\bigskip
\begin{lstlisting}
int utrace_set_flags(struct task_struct *target,
			 struct utrace_attached_engine *engine,
			 unsigned long flags);

\end{lstlisting}

\bigskip 
Существует специальный флаг - {\texttt UTRACE\_EVENT(QUIESCE)}, которы
й может переключать процесс в состояние ожидания. В общем случае, все 
операции с процессом в первую очередь требуют установки этого флага, п
осле чего можно ожидать исполнения коллбека {\texttt report\_quiesce()
}, который извещает об остановке процесса. Естьмножество других событи
й, извещения о которых могут быть получены отладочным движком. В их чи
сле fork(), exec(), получение сигнала, завершение процесса, вызов сист
емного вызова и др..

\bigskip
{\bfseries Uprobes.}

\bigskip
Uprobes является клиентом системы utrace и входит в состав утилит для 
наблюдения за событиями в системе Systemtap в качестве модуля ядра. Кр
оме этого, существуют патчи, позволяющие собрать uprobes непосредствен
но в ядро Linux. Основной функцией данного набора функций является обе
спечение возможности проставления контрольных точек в код отлаживаемог
о процесса и регистрация функций, обрабатывающих события, связанные с 
данными точками. Есть два типа таких контрольных точек: uprobes и uret
probes. Uprobe может быть установлена на любой адрес в виртуальном адр
есном пространстве процесса и сработает при попадании исполнения на ин
струкцию, расположенную по этому адресу. Uretprobe сработает при завер
шении работы указанной функции в отлаживаемом процессе. При регистраци
и точки останова, uprobes сохраняет копию инструкции, расположенной по
 этому адресу в приложении, останавливает его исполнение, подменяет пе
рвые байты по этому адресу на инструкцию точки останова (int3 на i386 
x86\_64) и вновь запускает исполняемое приложение. Когда исполнение по
падает на эту инструкцию, срабатывает ловушка и генерируестя сигнал SI
GTRAP. Uprobes получает этот сигнал и находит связанную с ним точку ос
танова и ее функцию-обработчик. Отлаживаемый процесс будет остановлен 
до завершения работы функции-обработчика. После завершения работы функ
ции-обработчика uprobes исполняет сохраненную команду, которая первона
чально располагалась по адресу точки останова в пользовательском проце
ссе и вновь запускает пользовательский процесс.   

Регистрация контрольной точки может быть произведена с помошью функции
 

\bigskip 
\begin{lstlisting}
#include <linux/uprobes.h>
int register_uprobe(struct uprobe *u); 
\end{lstlisting}

Будет установлена точка установа в виртуальном адресном пространстве п
роцесса u->pid по адресу u->vaddr и с обработчиком v->handler, который
 может быть определен следующим образом: 

\begin{lstlisting}
#include <linux/uprobes.h>
#include <linux/ptrace.h>
void handler(struct uprobe *u, struct pt_regs *regs);
\end{lstlisting}

\bigskip
При завершении отлаживаемого процесса, либо при вызове функции exec() 
uprobes автоматически удаляет все контрольные точки и их обработчики. 
При выполнении вызова fork() во вновь созданном процессе удаляютя все 
контрольные точки. 


\bigskip 
{\bfseries SELinux}
Итак, как уже было сказано, в SELinux три аттрибута безопасности: иден
тификатор пользователя, роль и тип вместе образуют так называемый конт
екст безопасности. SELinux хранит контексты безопасности в своих табли
цах, каждая запись в которых определяется идентификатором безопасности
, (SID), который представляет собой целочисленную переменную. Разным к
онтекстам ставятся в соответствие разные идентификаторы безопасности. 
При этом Security Server принимает все решения, описаные в логике поли
тики на основании двух идентификаторов взаимодействующих объектов. 

\bigskip
\subsection{Архитектура SELinux}
SELinux состоит из следующих основных компонент:
\begin{itemize}
\item Код в ядре (Security Server, hooks,selinuxfs)
\item Библиотека для взаимодействия с ядром
\item Политика безопасности
\item Различные инструменты
\item Размеченные файловые системы
\end{itemize}

\bigskip
{\bfseries Код в ядре}

Задачей SELinux в ядре является наблюдение за событиями в системе и пр
инятие решений о разрешении о различных операциях в соответствии с пол
итикой безопасности. Кроме этого, Security Server ведет логи для опред
еленных разрешенных или запрещенных операций, список которых описан в 
политике. Кроме этого Security Server заполняет соответствующие структ
уры безопасности в запускаемых приложениях. Такой структурой является 
следующая структура: 

\bigskip 
\begin{lstlisting}
	
struct task_security_struct {
	u32 osid;		
	u32 sid;	
	u32 exec_sid;		
	u32 create_sid;		
	u32 keycreate_sid;	
	u32 sockcreate_sid;	
};

\end{lstlisting}

\bigskip
На нее указывает поле security в структуре task\_struct. Поля структур
ы безопасности включают в себя следующую информацию. 

\begin{tabular}{|p{3cm}|p{9cm}|}
\hline 
\ttfamily Поле 
& 
Описание \\ 
\hline
osid
& 
Старый идентификатор, который был у процесса, до выполнения execve. \\

\hline
sid
& 
Текущий идентификатор \\
\hline
exec-sid
&
Идентификатор, использующийся для определения прав на выполнение exec.
 \\
\hline
create\_sid 
&
Идентификатор, которым будут помечены объекты ФС, созаваемые данным пр
оцессом \\
\hline
keycreate\_sid
& 
Идентификатор, который будет присвоен ? \\ 
\hline
sockcreate\_sid  
&
Идентификатор для сокетов данного процесса. \\ 
\hline
\end {tabular}

\bigskip
В нашем случае интересно поле sid. Именно на основании значения данног
о поля в Security Server принимаются решения согласно логике политики 
SELinux. 

\bigskip
{\bfseries Библиотка работы с интерфейсами SELinux} 
Данная библиотека (libselinux.so) используется большинством из компоне
нт SELinux, находящихся в пользовательском пространстве.

\bigskip
{\bfseries Политика безопасности SELinux} 
Сервер безопасности принмает все свои решения на основании политики бе
зопасности, описанной администратором системы. При запуске системы SEL
inux загружает политику безопасности из бинарного файла, который, как 
правило находится в /etc/security/selinux. 

\bigskip
{\bfseries Инструменты} 
В первую очередь SELinux предоставляет набор инструметнов для админист
рирования системы, компиляции политики в бинарное представление, добав
ления новых ролей, изменения меток файлов. Корме этого некоторые систе
мные команды и программы заменяются модифицированными аналогами, среди
 них cp, mv, install, id, ls, ps, login, logrotate, pam, ssh и прочие.
 Существуют различные инструменты, призванные упростить работу с SELin
ux, в том числе инструменты с графическим интерфейсом такие как Apol, 
SeAudit, SeCmds, SePCuT, SeUser. 
