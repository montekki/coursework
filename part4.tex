\section{Решение задачи}

\subsection{Реализация системы контроля поведения
		наблюдаемого приложения}
\bigskip

Результатом работы прошлого года стали изменения в 
ядре Linux, позволяющие динамически переключать
контексты приложения. Изменения были внесены в ядро
версии 2.6.26. Также было предложено использовать 
подсистемы utrace и uprobes для простановки контрольных 
точек в наблюдаемом приложении. 

В этом году был реализован модуль ядра, позволяющий
динамическую смену конеткста безопасности приложения 
при прохождении исполнения через контрольные точки. 
В связи с переносом всего решения на ядро версии 
2.6.32 возникла необходимость полностью переделать 
работу проделанную в прошлом году. Реализацию 
указанного модуля можно разделить на две составляющие. 

Первой из них является использование систем uprobes и 
utrace для расстановки контрольных точек в наблюдаемых 
процессах. Были реализованы списки наблюдаемых процессов,
списки контрольных точек в этих процессах, функции обработчики 
событий происходящих в наблюдаемых процессах. 

Второй частью является полностью переделанная из-за переноса 
на ядро новой версии система поддержки динамических изменений
контекстов SELinux. Эта система используется в реализованном 
модуле для обработки событий перехода процесса в новое состояние,
которые предусматривают смену политики, применяемой к приложению. 

Кроме этого было решено отказаться от модификации синтаксиса 
политик SELinux с целью сделать изменения вносимые в исходную 
систему минимальными. Вместо этого были реализованы интерфейсы 
получения из пользовательского пространства всей необходимой 
информации о наблюдаемых процессах и контрольных точках в них.

\subsection{Выбор уязвимого сетевого приложения}
\bigskip

Для доказательства актуальности разработанного механизма 
контроля и его корректной работы, необходимо продемонстрировать
пример уязвимого приложения, которое является уязвимым 
несмотря на наличие политики SELinux, а реализованное средство 
позволяло бы минимизировать эффект от успешной атаки на данное 
приложение. 

В качестве примера такого приложения был выбран сетевой демон OpenSSH.
OpenSSH является типичным примером приложения, работающего с 
системными правами и с практически полным набором разрещающих прав
SELinux. В том числе, в случае успешной атаки на буфер,
политика SELinux, применяемая к данному приложению не запрещает 
злоумышленнику получить удаленный шелл, сделав вызов system() в 
уязвимом процессе. Это логично, так как демону ssh необходимы права
на вызов функций fork() и exec().

Тем не менее, пример уязвимости в этом приложении должен быть достаточно 
простой для эксплуатации. 

За последнее время в указанном приложении не было обнаружено 
таких уязвимостей, поэтому было решено внести такую уязвимость 
в код приложения вручную. 

В ходе более пристального исследования архитектуры OpenSSH 
оказалось, что разработчики реализовали разбиение приложения
на состояния, обладающие различными правами. Технически 
это осуществляется при помощи порождения новых процессов 
с меньшими привилегиями, которые обрабатывают пользовательский 
ввод, операции с сетью и криптоалгоритмы. Эти новые процессы 
меняют свою корневую директорию на /var/empty делая 
невозможным запуск любых процессов из кода этого дочернего процесса, 
в том числе, в случае успешной атаки на обнаруженные в нем уязвимости. 

Это существенно осложняет реализацию искуственного внесения 
уязвимостей в OpenSSH. Кроме того, описанная выше архитектура
ставит под сомнение сам выбор OpenSSH в качестве требуемого 
примера. Кроме этого, стоит отметить, что множество других 
защитных механизмов, работающих в Linux делают искуственное 
внесение уязвимосте в приложение достаточно сложным процессом. 
В числе таких механизмов можно отметить различные системы защиты 
стека от исполнения и подмены адреса возврата из функции, 
рандомизацию адресного пространства, права чтение, запись и 
исполненье различных секций памяти процесса. 

Из-за указанных технических сложностей на данный момент не удалось 
привести требуемый пример уязвимого приложения.

\subsection{Защита контрольных точек от модификации в процессе 
		выполнения}
\bigskip

При использовании контрольных точек сразу возникает вопрос 
в возможности их модификации и фальсификации злоумышленником.
Для успешности контроля переходов приложения в новые состояния
мы должны быть уверены в подлинности контрольных точек. 

В реализации работы контрольной точкой является инструкция 
прерывания, записываемая в сегмет кода процесса. Очевидно, что 
сегмент кода не является модифицируемым, что позволяет считать 
контрольные точки надежными. 

\begin{comment}
\subsection{Схема работы решения}

Работу инфраструктуры поддержки 
контроля состояния приложения можно 
представить в виде последовательности шагов.
\bigskip
\begin{itemize}
\item   Выделение некоторого набора адресов 
	контрольных точек из программы. 	


\item 	Сопоставление информации о контрольных 
	точках информации о смене состояний
	приложения

\item 	Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.
	При этом смена контекста должна происходить
	абсолютно прозрачно для приложения. Это 
	значит, что в том случае, если злоумышленнику
	удается получить контроль над приложением, 
	для изменения его контекста безопасности 
	ему придется воспроизвести нормальный ход
	исполнения этого приложения до смены 
	конекста в какой-либо контрольной точке.  

\end{itemize}  

Рассмотрим эти шаги более подробно. 

Пусть в наличии имеются исходные 
тексты приложения и информация о том, 
как приложение было собрано. 
Изначально, на этапе подготовки, человек
расставляет метки в исходных текстах 
программы. Эти метки являются адресами в 
виртуальном адресном пространстве приложения. 
При помощью метода, описанного в разделе "Реализация 
механизма получения адресов контрольных точек", 
при компиляции приложения попадают 
в отдельную секцию в результирующем 
исполняемом файле. Далее выполняются 
все операции именно с этими метками. 

Имея в наличии адреса в коде и информацию 
о смене состояний, связанную с этими контрольными
точками, 
человеком создается конфигурационный файл, 
формализующий связь между информацией о 
состояниях и контрольными точками. После 
этого данный файл транслируется в специальное 
бинарное представление, подходящее для использования
в модуле контроля за состояниями приложения. Данный 
способ более подробно описывается в подразделе 
"Сопоставление информации о контрольных точках 
информации о смене состояний приложения". 

Во процессе работы программы при помощи 
средства utrace, рассмотренном в разделе 5.1, 
обнаруживаются "попадания" на метки. Данные 
события приводят к смене контекста приложения. 
Смена контекста производится при помощи добавленных 
в ядро функций, которые описаны в разделе "Особенности 
реализации". 

\bigskip 
\subsection{Реализация механизма получения
	адресов контрольных точек.}

Рассмотрим процесс этап подготовки программы 
и получение адресов меток непосредственно из 
бинарного исполняемого файла. 

В данной работе под контрольной точкой 
подразумевается адрес в виртуальном 
адресном пространстве процесса. 
Данные контрольные точки разграничивают
внутренние состояния приложения.  
В первую очередь, возникает необходимость 
некоторым образом разметить код приложения 
контрольными точками, а точнее, получить адреса 
в виртуальном адресном пространстве приложения. 
В данной работе будет рассматриваться только
разметка кода приложений, написанных на C/C++ 
на основании их исходных текстов. Это возможно 
сделать при помощи  расширения GCC, позволяющего
управлять размещением данных в результирующем 
коде приложения. Предлагается при помощи 
этого расширения создавать секцию в бинарном 
исполняемом файле, содержащую адреса 
контрольных точек.

Пример: 

\bigskip
\begin{lstlisting}
#include <stdio.h>
int main (int argn, char *argv[])
{ 
	static void * ret[2] __attribute__((section(".mylabels"),used)) = 
		{&& ret1,&& ret2};
	if (argn > 2) {
	ret1:
		printf("1 n");
	} else {
	ret2:
		printf("2 n");
	}	
	return 0;
}
\end{lstlisting}

\bigskip
В данном примере есть две метки. Можно сказать, что 
здесь они определяют две различные ветви исполнения 
программы. Средства компилятора gcc позволяют управлять 
размещением данных в бинарном файле программы при помощи 
команды \_\_attribute\_\_. При помощи этой команды в исполнимом 
файле возможно создать отдельную секцию, содержащую эти адреса. 
Исполнимые файлы с данной секцией и без нее будут отличаться 
только наличием этой секции, при этом в файле с данной секцией 
все адреса останутся теми же, что и в файле без секции. Таким 
образом мы получаем очень удобный способ хранения адресов прямо 
в бинарном файле программы, откуда их можно извлекать для 
дальнейшей обработки, либо читать эту информацию прямо перед 
запуском приложения. Важно, что в большинстве случаев адреса 
в оптимизированном коде с метками не отличаются от адресов в оптимизированном 
коде без меток. Это было показано в ходе серии экспериментов. 

\bigskip 
\subsection{Связь информации об адресах контрольных точек с изменениями
	контекста приложения} 

Для наблюдения за состояниями приложения и переключения 
контекстов во время исполнения необходимо некоторым образом связать 
информацию об адресах контрольных точек с информацией об
изменениях контекста безопасности приложения, соответствующих
данным контрольным точкам. 

\bigskip
{\bfseries Недостатки данного подхода.} 

Основным недостатком данного подхода является необходимость
внедрять вызовы интерфейсов динамического изменения контекста
непосредственно в приложение. Предлагаемый же подход
предполагает использование немодифицированных приложений.

Это влечет за собой сразу 
несколько серьезных проблем. Во-первых, маловероятно, что 
разработчики будут делать это самостоятельно, тем более, 
что у них получится корректно выделить те участки кода, 
на которых приложению нужны различные привилегии, и 
корректно определить необходимые контексты. В таком случае, 
для обеспечения возможности использования этого метода, 
приложение должны изменять третьи разработчики, следовательно, 
такие приложения будут отличны от основной ветки и патчи 
вместе с пересборкой придется осуществлять при выходе 
каждого очередного релиза приложения. Но более 
серьезной проблемой является то, что информация передается 
непосредственно из пользовательского пространства в ядро. 
В данном случае на стороне ядра невозможно определить, 
был ли сделан данный вызов в ходе нормального хода 
выполнения приложения, либо злоумышленник изменил нормальный
ход выполнения и выполнил данный вызов с целью повышения 
прав.

\bigskip
Предлагается хранить информацию о состояниях 
приложения и контрольных точках в файле, который 
содержал бы необходимую информацию и был бы компактен.
Как уже говорилось ранее, идентификатор безопасности 
целочисленной величиной, которой ставится в соответствие 
символьное представление контекста безопасности. Для 
описания необходимости изменить контекст приложения 
при попадании исполнения на определенный адрес предлагается 
использовать следующую конструкцию: 

\bigskip
\begin{lstlisting}
context_1 context_2 addr
\end{lstlisting}

\bigskip
Данная конструкция будет объявлять, что для приложения
с контекстом context\_1 необходимо произвести смену 
контекста на context\_2 при попадании исполнения на 
инструкцию по адресу addr.
Проблема наблюдения за данными адресами может быть реализована 
по-разному. Можно использовать вызов ptrace и создавать 
сложную систему методов для наблюдения за событиями в 
наблюдаемом приложении. При этом, обязательно нужно 
следить за такими событиями, как fork и exec для определения, 
в какое состояние переходит приложения. Так же наблюдение за exec 
обеспечит определение факта запуска определенного приложения. Такой 
контроль предлагается осуществлять при помощи системы utrace и 
ее клиента~--- uprobes. Utrace является патчем ядра от Red 
Hat, позволяющим строить отладочные движки, работающие в 
пространстве ядра в качестве загружаемых модулей. Uprobes 
является клиентом utrace и позволяет устанавливать точки 
останова на определенные адреса в коде и для каждой из них 
регистрировать функции-обработчики, которые будут срабатывать каждый 
раз, как управление в приложении попадет на одну из точек останова.

\bigskip
\subsection{Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.}

\bigskip
Обычным интерфейсом отладки программ в ОС Linux является 
системный вызов ptrace(). Этот вызов является основой 
для построения отладчиков в пользовательском пространстве. 
Тем не менее, было решено весь механизм наблюдения 
за контрольными точками внести в ядро. Такое решение 
было принято с целью минимизации накладных расходов, 
так как отладка приложений, собранных с отладочной 
информацией ведет к серьезной потере производительности.

Не так давно появилась гораздо более удобная альтернатива 
использованию ptrace для отладки пользовательских 
приложений из пространства ядра в виде utrace~\cite{utrace}. Основной 
код данной системы не имеет интерфейсов в пользовательском 
пространстве. Вместо этого есть интерфейсы в ядре, которые 
позволяют создавать отладочные механизмы, работающие в пространстве 
ядра. Эти интерфейсы основаны на концепции ``отладочного движка'', 
который представляет собой обычную структуру, содержащую 
указатели на функции. У данной структуры есть четырнадцать указателей на
функции, которые будут вызваны в случае определенных событий в 
отлаживаемом приложении. Данная подсистема позволяет отслеживать 
самые разные события в отлаживаемом приложении такие, как системные 
вызовы, сигналы, изменения данных. Клиентом подсистемы utrace 
является uprobes~--- набор функций для расстановки точек
останова в отлаживаемое приложение. Предлагается использовать 
uprobes и utrace для наблюдения за контрольными точками и 
такими событиями, как fork/exec. Далее данная подсистема 
будет описана более подробно. Информацию о точках останова 
и о контекстах модуль будет получать из бинарного файла 
конфигурации. 

\end{comment}
