
\section{Решение задачи }

\subsection{Схема работы решения}

Работу инфраструктуры поддержки 
контроля состояния приложения можно 
представить в виде последовательности шагов.
\bigskip
\begin{itemize}
\item   Выделение некоторого набора адресов 
	контрольных точек из программы. 	


\item 	Сопоставление информации о контрольных 
	точках информации о смене состояний
	приложения

\item 	Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.
	При этом смена контекста должна происходить
	абсолютно прозрачно для приложения. Это 
	значит, что в том случае, если злоумышленнику
	удается получить контроль над приложением, 
	для изменения его контекста безопасности 
	ему придется воспроизвести нормальный ход
	исполнения этого приложения до смены 
	конекста в какой-либо контрольной точке.  

\end{itemize}  

Рассмотрим эти шаги более подробно. 

Пусть в наличии имеются исходные 
тексты приложения и информация о том, 
как приложение было собрано. 
Изначально, на этапе подготовки, человек
расставляет метки в исходных текстах 
программы. Эти метки являются адресами в 
виртуальном адресном пространстве приложения. 
При помощью метода, описанного в разделе "Реализация 
механизма получения адресов контрольных точек", 
при компиляции приложения попадают 
в отдельную секцию в результирующем 
исполняемом файле. Далее выполняются 
все операции именно с этими метками. 

Имея в наличии адреса в коде и информацию 
о смене состояний, связанную с этими контрольными
точками, 
человеком создается конфигурационный файл, 
формализующий связь между информацией о 
состояниях и контрольными точками. После 
этого данный файл транслируется в специальное 
бинарное представление, подходящее для использования
в модуле контролья за состояниями приложения. Данный 
способ более подробно описывается в подразделе 
"Сопоставление информации о контрольных точках 
информации о смене состояний приложения". 

Во процессе работы программы при помощи 
средства utrace, рассмотренном в разделе ***, 
обнаруживаются "попадания" на метки. Данные 
события приводят к смене контекста приложения. 
Смена контекста производится при помощи добавленных 
в ядро функций, которые описаны в разделе "Особенности 
реализации". 

\bigskip 
\subsection{Реализация механизма получения
	адресов контрольных точек.}

Рассмотрим процесс этап подготовки программы 
и получение адресов меток непосредственно из 
бинарного исполняемого файла. 

В данной работе под контрольной точкой 
подразумевается адрес в виртуальном 
адресном пространстве процесса. 
Данные контрольные точки разграничивают
внутренние состояния приложения.  
В первую очередь, возникает необходимость 
некоторым образом разметить код приложения 
контрольными точками, а точнее, получить адреса 
в виртуальном адресном пространстве приложения. 
В данной работе будет рассматриваться только
разметка кода приложений, написанных на C/C++ 
на основании их исходных текстов. Это возможно 
сделать при помощи  расширения GCC, позволяющего
управлять размещением данных в результирующем 
коде приложения. Предлагается при помощи 
этого расширения создавать секцию в бинарном 
исполняемом файле, содержащую ареса 
контрольных точек.

Пример: 

\bigskip
\begin{lstlisting}
#include <stdio.h>
int main (int argn, char *argv[])
{ 
	static void * ret[2] __attribute__((section(".mylabels"),used)) = 
		{&& ret1,&& ret2};
	if (argn > 2) {
	ret1:
		printf("1 n");
	} else {
	ret2:
		printf("2 n");
	}	
	return 0;
}
\end{lstlisting}

\bigskip
В данном примере есть две метки. Можно сказать, что 
здесь они определяют две различные ветви исполнения 
программы. Средства компилятора gcc позоляют управлять 
размещением данных в бинарном файле программы при помощи 
команды \_\_attribute\_\_. При помощи этой команды в исполнимом 
файле возможно создать отдельную секцию, содержащую эти адреса. 
Исполнимые файлы с данной секией и без нее будут отличаться 
только наличием этой секции, при этом в файле с данной секцией 
все адреса останутся теми же, что и в файле без секции. Таким 
образом мы получаем очень удобный способ хранения адресов прямо 
в бинарном файле программы, откуда их можно извлекать для 
дальнейшей обработки, либо читать эту информцию прямо перед 
запуском приложения. Важно, что в большинстве случаев адреса 
в оптимизированном коде с метками не отличаются от адресов в оптимизированном 
коде без меток. Это было показано в ходе серии экспериментов. 

\bigskip 
\subsection{Связь информации об адресах контрольных точек с изменениями
	контекста приложения} 

\begin{comment}
Для наблюдения за состояниями приложения и переключения 
контекстов во время исполнения необходимо некоторым образом связять 
информацию об адресах контрольных точек с информацией об
изменениях контекста безопасности приложения, соответствующих
данным контрольным точкам. 

\bigskip
{\bfseries Недостатки данного подхода.} 

Основным недостатком данного подхода является необходимость
внедрять вызовы интерфейсов динамического изменения контекста
непосредственно в приложение. Предлагаемый же подход
предполагает использование немодифицированных приложений.

Это влечет за собой сразу 
несколько серьезных проблем. Во-первых, маловероятно, что 
разработчики будут делать это самостоятельно, тем более, 
что у них получится корректно выделить те участки кода, 
на которых приложению нужны различные привилегии, и 
корректно определить необходимые контексты. В таком случае, 
для обеспечения возможности использования этого метода, 
приложение должны изменять третьи разработчики, следовательно, 
такие приложения будут отличны от основной ветки и патчи 
вместе с пересборкой придется осуществлять при выходе 
каждого очередного релиза приложения. Но более 
серьезной проблемой является то, что информация передается 
непосредственно из пользовательского пространства в ядро. 
В данном случае на стороне ядра невозможно определить, 
был ли сделан данный вызов в ходе нормального хода 
выполнения приложения, либо злоумышленник изменил нормальный
ход выполнения и выполнил данный вызов с целью повышения 
прав.
\end{comment} 

\bigskip
Предлагается хранить информацию о состояниях 
приложения и контрольных точках в файле, который 
содержал бы необходимую информацию и был бы компактен.
Как уже говорилось ранее, идентификатор безопасности 
целочисленной величиной, которой ставится в соответствие 
символьное представление контекста безопасности. Для 
описания необходимости изменить контекст приложения 
при попадании исполнения на определенный адрес предлагается 
использовать следующую конструкцию: 

\bigskip
\begin{lstlisting}
context_1 context_2 addr
\end{lstlisting}

\bigskip
Данная конструкция будет объявлять, что для приложения
с контекстом context\_1 необходимо произвести смену 
контекста на context\_2 при попадании исполнения на 
инструкцию по адресу addr.
\begin{comment}
Проблема наблюдения за данными адресами может быть реализована 
по-разному. Можно использовать вызов ptrace и создавать 
сложную систему методов для наблюдения за событиями в 
наблюдаемом приложении. При этом, обязательно нужно 
следить за такими событиями, как fork и exec для определения, 
в какое состояние переходит приложения. Так же наблюдение за exec 
обеспечит определение факта запуска определенного приложения. Такой 
контроль предлагается осуществлять при помощи системы utrace и 
ее клиента~--- uprobes. Utrace является патчем ядра от Red 
Hat, позволяющим строить отладочные движки, работающие в 
пространстве ядра в качестве загружаемых модулей. Uprobes 
является клиентом utrace и позволяет устанавливать точки 
останова на определенные адреса в коде и для каждой из них 
регистрировать функции-обработчики, которые будут срабатывать ккаждый 
раз, как управление в приложении попадет на одну из точек останова.
\end{comment} 

\bigskip
\subsection{Наблюдение за немодифицированным 
	приложением во время его исполнения 
	и смена его контекстов согласно 
	информации об изменении состояний.}

\bigskip
Обычным интерфейсом отладки программ в ОС Linux является 
системный вызов ptrace(). Этот вызов является основой 
для построения отладчиков в пользовательском пространстве. 
Тем не менее, было решено весь механизм наблюдения 
за контрольными точками внести в ядро. Такое решение 
было принято с целью минимизации накладных расходов, 
так как отладка приложений, собранных с отладочной 
информацией ведет к серьезной потере производительности.

Не так давно появилась гораздо более удобная альтернатива 
использованию ptrace для отладки пользовательских 
приложений из пространства ядра в виде utrace~\cite{utrace}. Основной 
код данной системы не имеет интерфейсов в пользовательском 
пространстве. Вместо этого есть интерфейсы в ядре, которые 
позволяют создавать отладочные механизмы, работающие в пространстве 
ядра. Эти интерфейсы основаны на концепции ``отладочного движка'', 
который представляет собой обычную структуру, содержащую 
указатели на функции. У данной стркутуры есть 14 указателей на
функции, которые будут вызваны в случае определенных событий в 
отлаживаемом приложении. Данная подсистема позволяет отслеживать 
самые разные события в отлаживаемом приложении такие, как системные 
вызовы, сигналы, изменения данных. Клиентом подсистемы utrace 
является uprobes~--- набор функций для расстановки точек
останова в отлаживаемое приложение. Предлагается использовать 
uprobes и utrace для наблюдения за контрольными точками и 
такими событиями, как fork/exec. Далее данная подсистема 
будет описана более подробно. Информацию о точках останова 
и о контекстах модуль будет получать из бинарного файла 
конфигурации. 

