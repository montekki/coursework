
{\bfseries Решение задачи разметки исполнимого кода программы контрольными точками и контроля за ее состояниями с использованием системы безопасности уровня ядра SELinux}

\bigskip 
{\bfseries Задача} 

Задача контроля текущего состояния приложения требует ввода некоторых определений. Определим состояние, как некоторый участок кода программы, относительно которого может быть принято решение, что для его исполнения нужны те или иные минимальные права. Одним из решений задачи контроля является патчинг кода программы функциями, которые бы сообщали о текущих изменениях состояния приложения. Такой подход не является не удовлетворительным, так как следствием успешной атаки на приложение может стать исполнение произвольного кода, который может исполнить одну из функций изменения состояний. Другое решение заключается в расстановке точек останова на определенные адреса в коде. Контроль должен осуществляться из пространства ядра. Этому есть несколько причин: модуль должен вносить некоторые изменения в логику работы SELinux Security Server, кроме этого, мы не можем доверять пользовательскому пространству. Кроме этого, информация о связи между адресами в коде и изменениях состояния приложения должна быть доступна для модуля, осуществляющего контроль. Таким образом, можно выделить две основные части работы - реализация механизма контроля за адресами в коде и расширение профилей SELinux.

\bigskip 
{\bfseries Реализация механизма наблюдения за состояниями процесса.}

Итак, в данной работе под контрольной точкой подразумевается некоторый адрес в виртуальном адресном пространстве процесса. Попадание исполнения на один из таких адресов, в общем случае, означает изменение состояния процесса. В первую очередь, возникает необходимость некоторым образом разметить код приложения контрольными точками, а точнее, получить адреса в виртуальном адресном пространстве приложения. В данной работе будет рассматриваться только разметка кода приложений, написанных на C/C++ на основании их исходных текстов. Это возможно сделать при помощи получения адресов меток, которые можно проставлять тех местах кода, где предполагается изменение состояния приложения. 

Пример: 

\bigskip
\begin{lstlisting}
#include <stdio.h>
int main (int argn, char *argv[])
{ 
	static void * ret[2] __attribute__((section(".mylabels"),used)) = 
		{&& ret1,&& ret2};
	if (argn > 2) {
	ret1:
		printf("1 n");
	{ else {
	ret2:
		printf("2 n");
	{
	return 0;
{ 
}
\end{lstlisting}
\bigskip
В данном примере есть две метки. Можно сказать, что здесь они определяют две различные ветви исполнения программы. Средства компилятора gcc позоляют управлять размещением данных в бинарном файле программы при помощи команды \_\_attribute\_\_. При помощи этой команды в исполнимом файле возможно создать отдельную секцию, содержащую эти адреса. Исполнимые файлы с данной секией и без нее будут отличаться только наличием этой секции, при этом в файле с данной секцией все адреса останутся теми же, что и в файле без секции. Таким образом мы получаем очень удобный способ хранения адресов прямо в бинарном файле программы, откуда их можно извлекать для дальнейшей обработки, либо читать эту информцию прямо перед запуском приложения.

Проблема наблюдения за данными адресами может быть реализована по-разному. Можно использовать вызов ptrace и создавать сложную систему методов для наблюдения за событиями в наблюдаемом приложении. При этом обязательно нужно следить за такими событиями, как fork и exec для определения, в какое состояние переходит приложения. Так же наблюдение за exec обеспечит определение факта запуска определенного приложения. Такой контроль предлагается осуществлять при помощи системы utrace и ее клиента~--- uprobes. Utrace является патчем ядра от Red Hat, позволяющим строить отладочные движки, работающие в пространстве ядра в качестве загружаемых модулей. Uprobes является клиентом utrace и позволяет устанавливать точки останова на определенные адреса в коде и для каждой из них регистрировать функции-обработчики, которые будут срабатывать ккаждый раз, как управление в приложении попадет на одну из точек останова. 

\bigskip
Описание отладочной системы Uprobes-utrace

\bigskip
Utrace.

\bigskip
Обычным интерфейсом отладки программ под Linux является системный вызов ptrace(). Как правило, он используется отладчиками. Данный интерфейс очень тяжело использовать, так как приходится создавать целую систему методов для разметки точками, наблюдения за событиями и прочих манипуляций над отлаживаемым приложением. 

С недавних пор появилась гораздо более удобная альтернатива использованию ptrace для отладки пользовательских приложений из пространства ядра в виде utrace. Основной код данной системы не имеет интерфейсов в пользовательском пространстве. Вместо этого есть интерфейсы в ядре, которые позволяют создавать отладочные механизмы, работающие в пространстве ядра. Эти интерфейсы основаны на концепции ``отладочного движка'', который представляет собой обычную структуру, содержащую указатели на функции. У данной стркутуры есть 14 функций-коллбеков, которые будут вызваны в случае определенных событий в отлаживаемом приложении. 

\bigskip 
Пример:

\bigskip
\begin{lstlisting}
u32 (*report_syscall_entry)(struct utrace_attached_ engine *engine,
				struct task_struct *tsk,
				struct pt_regs *regs);

\end{lstlisting}

\bigskip
Как только отлаживаемый процесс совершит системный вызов, будет вызвана соответствующая функция отлаживаемого движка - {\texttt report\_syscall\_entry()} (разумеется, если она была зарегистрирована). Вызов данного обработчика происходит до выполнения системного вызова, отладчик может безопасно полчать доступ к остановленному отлаживаемому процессу. Функция-обработчик возвращает битовую маску, которая определяет, что должно произойти далее~--- можно изменять состояние отладки, прекращать отладку, скрывать событие от других отладочных движков и многое другое. 

Отладочный движок регистрируется следующей функцией: 
\bigskip
\begin{lstlisting}
struct utrace_attached_engine *
    utrace_attach(struct task_struct *target, int flags,
	      	  const struct utrace_engine_ops *ops, 
		  unsigned long data);
  
\end{lstlisting}

\bigskip 
Данный вызов прицепит отладочный движок к указанному процессу. Возможна регистрация более чем одного отладочного движка для одного и того же процесса~--- серьезное отличие от ptrace(). Только что зарегистрированный движок ничего не делает и находится в состоянии idle. Для запуска необходимо указать соотвествующие флаги в вызове функции 

\bigskip
\begin{lstlisting}
int utrace_set_flags(struct task_struct *target,
			 struct utrace_attached_engine *engine,
			 unsigned long flags);

\end{lstlisting}

\bigskip 
Существует специальный флаг - {\texttt UTRACE\_EVENT(QUIESCE)}, который может переключать процесс в состояние ожидания. В общем случае, все операции с процессом в первую очередь требуют установки этого флага, после чего можно ожидать исполнения коллбека {\texttt report\_quiesce()}, который извещает об остановке процесса. Естьмножество других событий, извещения о которых могут быть получены отладочным движком. В их числе fork(), exec(), получение сигнала, завершение процесса, вызов системного вызова и др..

\bigskip
{\bfseries Uprobes.}

\bigskip
Uprobes является клиентом системы utrace и входит в состав утилит для наблюдения за событиями в системе Systemtap в качестве модуля ядра. Кроме этого, существуют патчи, позволяющие собрать uprobes непосредственно в ядро Linux. Основной функцией данного набора функций является обеспечение возможности проставления контрольных точек в код отлаживаемого процесса и регистрация функций, обрабатывающих события, связанные с данными точками. Есть два типа таких контрольных точек: uprobes и uretprobes. Uprobe может быть установлена на любой адрес в виртуальном адресном пространстве процесса и сработает при попадании исполнения на инструкцию, расположенную по этому адресу. Uretprobe сработает при завершении работы указанной функции в отлаживаемом процессе. При регистрации точки останова, uprobes сохраняет копию инструкции, расположенной по этому адресу в приложении, останавливает его исполнение, подменяет первые байты по этому адресу на инструкцию точки останова (int3 на i386 x86\_64) и вновь запускает исполняемое приложение. Когда исполнение попадает на эту инструкцию, срабатывает ловушка и генерируестя сигнал SIGTRAP. Uprobes получает этот сигнал и находит связанную с ним точку останова и ее функцию-обработчик. Отлаживаемый процесс будет остановлен до завершения работы функции-обработчика. После завершения работы функции-обработчика uprobes исполняет сохраненную команду, которая первоначально располагалась по адресу точки останова в пользовательском процессе и вновь запускает пользовательский процесс.   

Регистрация контрольной точки может быть произведена с помошью функции 

\bigskip 
\begin{lstlisting}
#include <linux/uprobes.h>
int register_uprobe(struct uprobe *u); 
\end{lstlisting}

Будет установлена точка установа в виртуальном адресном пространстве процесса u->pid по адресу u->vaddr и с обработчиком v->handler, который может быть определен следующим образом: 

\begin{lstlisting}
#include <linux/uprobes.h>
#include <linux/ptrace.h>
void handler(struct uprobe *u, struct pt_regs *regs);
\end{lstlisting}

\bigskip
При завершении отлаживаемого процесса, либо при вызове функции exec() uprobes автоматически удаляет все контрольные точки и их обработчики. При выполнении вызова fork() во вновь созданном процессе удаляютя все контрольные точки. 


\bigskip 
{\bfseries SELinux}
Итак, как уже было сказано, в SELinux три аттрибута безопасности: идентификатор пользователя, роль и тип вместе образуют так называемый контекст безопасности. SELinux хранит контексты безопасности в своих таблицах, каждая запись в которых определяется идентификатором безопасности, (SID), который представляет собой целочисленную переменную. Разным контекстам ставятся в соответствие разные идентификаторы безопасности. При этом Security Server принимает все решения, описаные в логике политики на основании двух идентификаторов взаимодействующих объектов. 

\bigskip
{\bfseries Архитектура SELinux}
SELinux состоит из следующих основных компонент:
\begin{itemize}
\item Код в ядре (Security Server, hooks,selinuxfs)
\item Библиотека для взаимодействия с ядром
\item Политика безопасности
\item Различные инструменты
\item Размеченные файловые системы
\end{itemize}

\bigskip
{\bfseries Код в ядре}
Задачей SELinux в ядре является наблюдение за событиями в системе и принятие решений о разрешении о различных операциях в соответствии с политикой безопасности. Кроме этого, Security Server ведет логи для определенных разрешенных или запрещенных операций, список которых описан в политике. Кроме этого Security Server заполняет соответствующие структуры безопасности в запускаемых приложениях. Такой структурой является следующая структура: 

\bigskip 
\begin{lstlisting}
	
struct task_security_struct {
	u32 osid;		
	u32 sid;	
	u32 exec_sid;		
	u32 create_sid;		
	u32 keycreate_sid;	
	u32 sockcreate_sid;	
};

\end{lstlisting}

\bigskip
На нее указывает поле security в структуре task\_struct. Поля структуры безопасности включают в себя следующую информацию. 

\begin{tabular}{|p{3cm}|p{9cm}|}
\hline 
\ttfamily Поле 
& 
Описание \\ 
\hline
osid
& 
Старый идентификатор, который был у процесса, до выполнения execve. \\
\hline
sid
& 
Текущий идентификатор \\
\hline
exec-sid
&
Идентификатор, использующийся для определения прав на выполнение exec. \\
\hline
create\_sid 
&
Идентификатор, которым будут помечены объекты ФС, созаваемые данным процессом \\
\hline
keycreate\_sid
& 
Идентификатор, который будет присвоен ? \\ 
\hline
sockcreate\_sid  
&
Идентификатор для сокетов данного процесса. \\ 
\hline
\end {tabular}

\bigskip
В нашем случае интересно поле sid. Именно на основании значения данного поля в Security Server принимаются решения согласно логике политики SELinux. 

\bigskip
{\bfseries Библиотка работы с интерфейсами SELinux} 
Данная библиотека (libselinux.so) используется большинством из компонент SELinux, находящихся в пользовательском пространстве.

\bigskip
{\bfseries Политика безопасности SELinux} 
Сервер безопасности принмает все свои решения на основании политики безопасности, описанной администратором системы. При запуске системы SELinux загружает политику безопасности из бинарного файла, который, как правило находится в /etc/security/selinux. 

\bigskip
{\bfseries Инструменты} 
В первую очередь SELinux предоставляет набор инструметнов для администрирования системы, компиляции политики в бинарное представление, добавления новых ролей, изменения меток файлов. Корме этого некоторые системные команды и программы заменяются модифицированными аналогами, среди них cp, mv, install, id, ls, ps, login, logrotate, pam, ssh и прочие. Существуют различные инструменты, призванные упростить работу с SELinux, в том числе инструменты с графическим интерфейсом такие как Apol, SeAudit, SeCmds, SePCuT, SeUser. 
