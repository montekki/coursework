\subsection{Обзор общих принципов работы рассматриваемых 
систем безопасности.} 

\bigskip
\paragraph{SELinux.}

\bigskip
{\bfseries Основные понятия. }

Принудительное присвоение типов (TE). 
И для процессов и для объектов используется 
один и тот же тип атрибутов. Поэтому достаточно 
одной матрицы достаточно для описания доступа к 
взаимодействию между разными типами, при этом 
объекты одного типа могут рассматриваться по-разному, 
если их их ассоциированные классы безопасности 
различны. Пользователи не привязаны к типам 
безопасности напрямую, вместо этого используется RBAC.

Ролевой контроль доступа (RBAC)  используется 
для определения множества ролей, которые могут 
быть назначены пользователям. SELinux расширяет 
модель RBAC до жесткой привязки пользовательских 
ролей к определенным доменам безопасности, роли 
могут быть организованы в виде иерархии приоритетов. 
Такая привязка ролей к доменам позволяет принимать 
большинство решений на основе конфигурации TE. 
Контекст безопасности кроме всего прочего включает 
в себя атрибут роли.

Многоуровневая система безопасности (MLS) 
SELinux предоставляет MLS для случаев, когда есть 
необходимость в традиционной многоуровневой системе 
безопасности. У объектов и субъектов могут быть 
различные уровни и категории. 
Как правило используется лишь один уровень. 

\bigskip
{\bfseries Практический обзор }

Главными элементами системы безопасности 
являются субъект, объект и действия. В классы 
объектов входят классы файлов (blk\_ file, chr\_ 
file, dir, fd,...\ ) ,  классы межпроцессного 
взаимодействия (ipc,msg,msgq,sem,shm), классы 
сетевого взаимодействия (key\_ socket,netif,node,
packet\_ socket,tcp\_ socket), классы объектов 
(passwd), системные классы (capability, process,
Secutity, System). Действия, которые субъекты 
SELinux могут предпринимать над объектами меняются
от класса к классу. Для классов файлов это, например, 
будут создание, исполнение, ссылки, чтение, запись, 
удаление. SELinux ассоциирует атрибуты безопасности 
с субъектами и объектами и основывает свои решения 
на этих атрибутах. Атрибутами являются: идентификатор 
пользователя, роль и тип. Идентификатор пользователя 
— пользовательская учетная запись, ассоциированная с 
субъектом или объектом. У каждого пользователя может 
быть несколько ролей, но в какой-то конкретный момент
времени ему может быть предписана только одна из них. 
Пользователь может менять роли командой newrole. Типы 
(а.к.а. Домены) делят субъекты и объекты на родственные 
группы. Это — главный атрибут безопасности, используемый 
SELinux для принятия решений. Типы позволяют помещать 
процессы в «песочницы» и предотвращать повышение 
привилегий. К примеру, роль суперпользователя - 
sysadm\_ r, его тип — sysadm\_ t. Политика безопасности 
SELinux загружается системой из бинарного файла политики,
который, как правило находится в /etc/security/selinux. 
Бинарная политика собирается при помощи make, исходные 
коды, как правило, находятся в /etc/security/selinux/src/policy.
Инструменты работы с SELinux могут быть разделены на 
три категории: специальные утилиты для настройки и 
использования SELinux, модифицированные версии стандартных 
команд и программ Linux, некоторые добавочные инструменты,
к примеру, для настройки и анализа политик. Среди основных 
команд можно выделить следующие: chcon – помечает файл или 
группу файлов указанным контекстом безопасности, checkpolicy
– позволяет выполнять множество действий, связанных с 
политиками, в том числе, компиляцию политики и ее загрузку 
в ядро; getenforce — позволяет узнать в каком режиме 
работает SELinux, newrole – позволяет пользователю 
перемещаться между ролями; run\_ init — позволяет 
запускать, останавливать или контролировать сервис; 
setenforce позволяет менять режим работы системы; 
setfiles присваивает метки указанной директории и ее 
поддиректориям. Некоторые из измененных программ: cron, 
login, logrotate, pam, ssh. Некоторые инструменты: Apol 
– инструмент для анализа файла policy.conf; SeAudit – 
инструмент для анализа логов, имеющий графический интерфейс; 
SeCmds; SePCuT — инструмент для просмотра и редактирования 
файлов политик; SeUser — модификация пользовательских 
учетных записей. 

\bigskip
{\bfseries Краткий обзор анатомии политики SELinux.}

Файлы политики организованы в виде дерева каталогов, 
корнем которого, как правило, является /etc/security/selinux/src/policy/. 
Основными поддиректориями являются: appconfig 
(определяет дефолтные типы контекстов безопасности); 
domains (определяют домены принудительного присвоения типов); 
file\_contexts (определяют контексты безопасности файлов), 
flask (определяет символы, испльзуемые ядром, совместимым 
с SELinux), macros (определяет макрос М4, используемый в 
исходных текстах политик), tmp (хранит сорцы политик во 
время компиляции), types (определяет несколько главных 
типов, которые не ассоциируются с конкретными доменами). 
Как правило существует два файла, которые определяют домен: 
FC file (file context), определяет контексты безопасности 
директорий и файлов, связанных с данным доменом); TE file 
(type enforcement, определяет вектор правил доступа и 
операций, связанных с доменом). Целью данного обзора не является. 

\bigskip
{\bfseries 5.2. AppArmor.}

AppArmor является системой безопасности, поддерживаемой 
компанией Novell, включена в дистрибутивы openSUSE и SUSE 
Enterprise. В AppArmor для определения того, к каким 
системным ресурсам и с какими привилегиями может 
получить доступ то или иное приложение используются 
политики безопасности (profiles). В отличие от SELinux, 
в которой настройки глобальны для всей системы, профили 
AppArmor разрабатываются индивидуально для каждого 
приложения. Изначально в AppArmor включен набор 
стандартных профилей, запускаемых после установки. 
Отдельно доступны профили для разных популярных программ 
и серверов. Кроме этого существуют инструменты для генерации 
профилей (genprof и logprof). Основная идея — верный выбор 
приложений, нуждающихся в ограничении привилегий и 
создание/редактирование профилей безопасности. Таким 
образом, в случае эксплойта, нанесенный ущерб сводится 
к минимуму. Система может работать в двух режимах: режиме 
обучения (complain) и в принудительном режиме (enforce). 
В первом из них все нарушения правил профиля разрешены, 
но немедленно регистрируются. Загрузка профиля в 
принудительном режиме предписывает системе отправлять 
сообщения о нарушениях в syslogd. Запуск и остановку 
AppArmor можно осуществлять при помощи команды rcapparmor 
с одним из следующих параметров: start (загрузка модуля 
ядра, анализ профиля, монтирование своей фс); stop (фс 
размонтируется, профили становятся недействительными); 
reload (перезагрузка профилей), status (информация о 
количестве запущенных профилей, в каком режиме они 
работают). Инструменты командной строки AppArmor: autodep 
(создает приблизительный профиль для программы или 
рассматриваемого приложения); complain (устанавливает 
профиль AppArmor в обучающий режим); enforce (переводит 
профиль в принудительный режим); genprof (генерирует профиль,
программа указывается при запуске); logprof (управляет
профилями AppArmor); unconfined (выводит список процессов 
с портами tcp и udp, которые не имеют загруженных 
профилей AppArmor). Система AppArmor построена на системе 
полных путей к файлам, проще говоря, типичное описание 
профиля выглядит примерно так: 

\bigskip
\begin{flushleft}
\texttt{\#include <tunables/global> \\  
/usr/bin/man { \\ 
	\#include <abstractions/base> \\
	\#include <abstractions/nameservice> \\
	capability setgid, \\
	capability setuid, \\
	/usr/lib/man-db/man Px,}\\ 
}
{\sloppy

}
\end{flushleft}

\bigskip
Профиль состоит из файлов, каталогов с указанием полных 
путей к ним и прав доступа к этим объектам. При этом r — 
разрешение на чтение, w — запись(за исключением создания 
и удаления файлов), ix — исполнение и наследование текущего 
профиля, px — исполнение под специфическим профилем, Px — 
защищенное выполнение, ux — неограниченное исполнение, 
Ux — защищенное неограниченное исполнение, m — присвоение 
участку памяти атрибута «исполняемый», I — жесткая ссылка. 
Чтобы подключить готовый профиль к AppArmor, достаточно его 
скопировать в каталог /etc/apparmor.d. 

\bigskip
{\bfseries PaX }

Основная цель данного проекта — изучение различных защитных 
механизмов, защищающих от эксплойтов уязвимостей ПО, которые 
предоставляют злоумышленнику полные права на чтение/запись в 
системе. Исполнение кода связано с необходимостью изменять 
ход выполнения процесса используя уже существующий код. Одна 
из основных проблем — подмена адресов возврата из функций и 
подмена самих адресов функций. Для установки PaX требуется 
наложить патч на дерево исходных кодов ядра, после чего собрать 
ядро и установить в систему. 

\bigskip
{\bfseries Trusted BSD.}

Проект TrustedBSD – проект разработки расширения существующей системы 
безопасности FreeBSD, включая расширенные атрибуты UFS2, 
списки контроля доступа, OpenPAM, аудит событий 
безопасности с OpenBSM, мандатное управление доступом 
и TrustedBSD MAC Framework. Trusted BSD была задумана 
как система, удовлетворяющая стандартам «оранжевой книги». 
Расширенные атрибуты UFS2 позволяют ядру и 
пользовательским процессам помечать файлы 
именованными метками. Это предоставляет место для 
хранение данные, необходимые системе безопасности, 
такие, как ACL и метки MAC. Списки контроля доступа 
— расширения дискреционного контроля доступа. Аудит 
системных событий позволяет вести избирательный 
логгинг важных системных событий для последующего 
анализа, обнаружения вторжений, и мониторинга в 
реальном времени. Начиная с версии 5.0 в ядре FreeBSD 
появилась поддержка MAC Framework, прошедшая испытания 
в TrustedBSD. Данный фреймворк позволяет создавать политики, 
определяющие принудительное присвоение доменов и типов (DTE), 
многоуровневую систему безопасности (MLS). Данный фреймворк 
предоставляет интерфейсы управления фреймворком, примитивы 
для синхронизации, механизм регистрации политик, примитивы 
для разметки объектов системы, разные политики, 
реализованные в виде модулей политики MAC и набор 
системных вызовов для приложений. При регистрации 
политики, происходит регистрация специальной структуры 
(struct mac\_policy\_ops), содержащей функции MAC 
framework, реализуемые политикой. На данный момент 
существуют следующие политики: 

mac\_biba – Реализация политики Biba, во многом 
схожей с MLS. Позволяет присваивать объектам и 
субъектам системы атрибуты доступа, которые образую 
иерархию уровней. Все операции над информацией в 
системе контролируются исходя из уровней 
взаимодействующих сущностей. 

mac\_ifoff позволяет администраторам контролировать 
сетевой трафик. 

mac\_lomac (Low-watermark MAC) еще одна 
реализация многоуровневого контроля доступа. 

mac\_bsdextended (file system firewall ) Система 
защиты файлов, основанная на определении прав 
доступа на основании роли пользователя. 

mac\_mls~--- реализация политики MLS. Объекты 
классифицируются  некоторым образом, субъектам 
присваивают уровень доступа. 

\bigskip
{\bfseries ОС «Феникс».}

ОС «Феникс» является отечественной разработкой — 
разработка СпбГУ, целью которой является создание 
специальной защищенной операционной системы класса 
Unix, отвечающей отечественным требованиям и 
стандартам информационной безопасности. «Феникс» 
представляет собой микроядерную, многопользовательскую, 
многозадачную, многопоточную операционную систему класса 
UNIX со встроенными механизмами защиты, 
обеспечивающими контроль взаимодействий, управление 
доступом, контроль целостности, 
идентификацию/аутентификацию пользователей 
и возможность подключения средств шифрования. 
Микроядерная архитектура отвечает принципу 
интегрированности, поскольку только в микроядерных 
системах для взаимодействий используется 
единственный способ — обмен сообщениями. 
Контроль доступа органично встраивается в этот 
механизм, причем, установив тотальный контроль 
над потоками сообщений, можно быть уверенным в 
том, что контролируются все взаимодействия в системе.
Принцип инвариантности определил организацию всех 
взаимодействий в «Феникс» на основе архитектуры 
клиент-сервер. В соответствии с принципом унификации 
доступ к объектам в «Феникс» осуществляется через 
Унифицированный Интерфейс Доступа к Объектам (УНИДО), 
определяющий множество операций, универсальных для 
всех типов объектов, в виде универсального набора 
методов, позволяющего выполнять все операции доступа к 
объектам, их создания и уничтожения, управления их
свойствами. Использование УНИДО единственный способ 
выполнения операций над объектами в «Феникс». 
Интерфейс оформлен в виде абстрактного класса, от 
которого наследуются интерфейсы всех серверов «Феникс», 
реализуемых УНИДО. Наличие набора типовых операций 
упрощает реализацию контроля доступа, поскольку 
определено однозначное соответствие между методами 
УНИДО и операциями доступа, описываемыми моделями 
безопасности. 

\bigskip
{\bfseries Vista Kernel-Mode Security.}

В ОС Windows Vista была расширена модель 
безопасности, присутствовавшая в предыдущих 
версиях системы(вплоть до XP SP2). Среди 
нововведений стоит отметить цифровые подписи 
драйверов, PatchGuard, Kernel-mode Code 
Integrity Checks, optional support for Secure 
Bootup using a TPM hardware chip, restricred 
user-mode access to \\ Device\\ PhysicalMemory. 

\bigskip
{\bfseries Driver Signing }. Анализируя эксплойты 
уязвимостей прошлых версий ОС, мы можем 
прийти к выводу, что наиболее распространенный 
способ, используемый вредоносным кодом для 
проникновения в ядро — проникновение через 
драйверы. Поэтому Vista не только требует подписи 
от драйвера, но и требует подпись именно от одного 
из восьми доверенных сертификатов. 

\bigskip
{\bfseries PatchGuard} был разработан для предотвращения 
патчей ядра ОС Виста х64. Защищает ядро путем периодической 
проверки на валидность некоторых структур данных и образов 
системы. PatchGuard кроется в NTOSKRNL.EXE и проверяет особо 
критичные системные структуры через случайные промежутки 
времени, обычно порядка 5-10 минут. Если была обнаружена 
модификация, «system will blue screen with the following 
bugcheck(which will obviously cause the user to lose all 
unsaved data)». (возможно ли обнаружить и убить тред 
PatchGuard?) 

\bigskip
Disabling \\Device\\PhysivalMemory 
Отказ от возможности доступа к Disabling \\ Device\\ PhysivalMemory 
из пользовательского пространства тоже является 
серьезным шагом на пути предотвращения доступа вредоносного кода к ядру. 

\bigskip
{\bfseries Code Integrity (CI.DLL) }
Импортируется статически NTOSKRNL. Защищает систему 
тем, что проверяет  системные исполняемые файлы на 
наличие изменений, в том числе и из-за внедрения 
вредоносного кода, наличие в системе неподписанных 
драйверов, запущенных в режиме ядра. В чем же отличие 
CI от PatchGuard, если они предоставляют схожую 
функциональность? CI может быть отключен, если 
отключены integrity checks, PatchGuard всегда включен. 
Кроме этого, эти методы разрабатывались разными 
командами внутри Microsoft и по заявлениям 
разработчиков, служат разным целям. 

\bigskip
{\bfseries Возможные направления атак. }
Kernel-Mode Network Drivers. 
Виста поддерживает некоторые сетевые протоколы 
в виде драйверов уровня ядра. Если уязвимость 
обнаружена в одном их этих подписанных драйверах, 
это бы дало возможность заполучить удаленный 
контроль над всей машиной. 

Disabling Driver Signing and Code Integrity 

Самый простой путь преодоления всех сложностей, 
связанных с подписями драйверов — патч исполняемых 
файлов и отключение проверок подписей вообще. 
Для загрузки неподписанных драйверов во время 
выполнения NTOSKRNL.EXE должен быть пропатчен. 
Но, патч ядра несет угрозу его цифровой подписи, 
следовательно, WINLOAD.EXE откажется загружать ядро.

\bigskip
{\bfseries Apple Seatbelt. }

Кроме возможности использования интерфейсов 
при программировании, позволяет помещать приложения 
в «песочницу», где их поведение будет контролироваться 
на основании определенных профилей. Данные профили 
находятся в /usr/share/sandbox и состоят из 
allow/deny определений и регулярных выражений 
для определения прав доступа к ресурсам системы. 
Объекты определяются по абсолютному пути (POSIX). 
Пример конфигурационного файла: 

\begin{flushleft}
\bigskip
\texttt{(version1)\\
(debug deny)\\
(allow default)\\
(allow process*)\\
(deny network-outbound)\\
(allow file-read-data file-read-metadata\\
(regex "\^ /.*"))\\
(deny file-write* \\
(regex "\^ /.*"))\\
(allow file-write*\\
(regex "\^ /Users/johndoe/Library/Preferences.*"))\\
(allow file-write* file-read-data file-read-metadata\\
(regex "\^ (/private)?/tmp/"))\\
(import "bsd.sb")
}
\bigskip
\end{flushleft}

Помещение в «песочницу» приложения на Cocoa производится следующим образом:
\% sandbox-exec -n localonly /Applications/TextEdit.app /Contents/MacOS/TextEdit
