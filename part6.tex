
\bigskip
\subsection{Предлагаемый подход}

Предлагаемый подход заключается в создании 
модуля ядра, который имел бы возможность наблюдать
за ходом исполнения приложения используя систему 
utrace-uprobes. Информацию о состояниях приложения
возможно получать из внешнего файла, который был 
бы подобен файлу политики SELinux, но содержал бы
лишь необходимую информацию и был бы очень компактен. 
При этом предлагается не вносить никаких изменений 
в язык SELinux и использовать те конструкции, которые 
использует система динамического изменения контекста. 
При этом в ядре понадобится функция, подобная 
selinux\_setprocattr(), которая должна экспортироваться
в остальное пространство ядра, либо возможно добавление
еще одного метода в LSM, который бы эта функция 
реализовывала. Преимуществами такого подхода являются: 

\bigskip
\begin{itemize}
\item Изменения существующей архитектуры SELinux минимальны, 
необходимо лишь добавление одной функции в пространство ядра. 
\item Исчезает необходимость изменения существующих приложений
путем добавления в их код вызовов методов динамического 
изменения контекста, использование которых является спорным
с точки зрения безопасности. 
\item С использованием utrace-uprobes появляется удобный
механизм наблюдения за практически любыми событиями в 
приложении и выполнения любых действий в случае их 
возникновения, в том числе за:
	\begin{itemize}
	\item Попаданием исполнения на определенные 
	адреса в коде. 
	\item Исполнением процессом вызовов fork/execx.
	\item Системными вызовами. 
	\end{itemize}
\item Существенно повышается скорость работы из-за 
отсутствия добавления системных вызовов в пользовательские 
приложения. 
\end{itemize}

\bigskip
{\bfseries Файл, содержащий информацию о смене контекстов
приложений } 
Как уже говорилось ранее, идентификатор безопасности 
целочисленной величиной, которой ставится в соответствие 
символьное представление контекста безопасности. Для 
описания необходимости изменить контекст приложения 
при попадании исполнения на определенный адрес предлагается 
использовать следующую конструкцию: 

\bigskip
\begin{lstlisting}
context_1 context_2 addr
\end{lstlisting}

\bigskip
Данная конструкция будет объявлять, что для приложения
с контекстом context\_1 необходимо произвести смену 
контекста на context\_2 при попадании исполнения на 
инструкцию по адресу addr. При этом конфигурационный 
файл, содержащий такие предложения, довольно просто перевести
в формат, содержащий следующие структуры данных: 

\bigskip 
\begin{lstlisting} 
typedef struct dyntran_info {
	uint32_t ssid;
	uint32_t tsid; 
	long 	 bpt;
}dyntran_info_t;
\end{lstlisting}

\bigskip
Преимущества создания такого бинарного файла состоят в следующем: 
в ядро попадает информация уже в той форме, в которой 
ее удобно представлять и осуществлять все необходимые 
манипуляции. В противном же случае приходилось бы при загрузке
файла, содержащего символьную информацию производить 
массу операций связанных с определением наличия указанных
контекстов в политике. При работе модуля приходилось бы 
постоянно производить приведение целочисленных идентификаторов
к их строковму представлению и обратно. 

