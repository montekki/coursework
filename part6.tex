
\bigskip
\section {Заключение} 

Предложенный метод решения задачи 
позволяет осуществлять контроль за 
состояниями приложения во время исполнения.

Метод проставления контрольных точек
на уровне исходных текстов приложения позволяет 
отслеживать изменения состояний исходных 
приложений, без необходимости их изменять. 
В данной работе задача получения 
адресов контрольных точек решена при помощи 
использования расширений компилятора GCC 
для создания секции, содержащей адреса в 
виртуальном адресном пространстве приложения.
В тех случаях, когда нет доступа к исходным 
текстам данная задача может быть решена при 
помощи отладки приложения. 

Разработанная программная инфраструктура 
поддержки контроля состояния приложения 
по контрольным точкам использует 
существующие решения, в числе которых система 
разработки отладчиков, работающих в пространстве 
ядра, существующая в SELinux система динамических 
изменений контекстов. Система контроля за 
состоянием приложения может быть сравнительно 
легко расширена до контроля за несколькими процессами, 
в том числе и за процессами, порожденными вызовами 
fork/exec. 


\bigskip
\begin{thebibliography}{99}
\bibitem{SEOF} 
Официальная документация SELinux 
(http://www.nsa.gov/research/selinux/docs.shtml)
\bibitem{AppArmor} 
Документация по проекту AppArmor 
(http://en.opensuse.org/AppArmor\_Geeks)
\bibitem{pax} 
GRSecurity ( http://pax.grsecurity.net/)

\bibitem{LDD}
Разработка драйверов в ОС Linux 
(Linux Driver Development by Johnatan Corbet, 
Greg Kroah-Hartman)
\bibitem{ULK} 
Ядро Linux (Daniel P. Bovet, Marco Cesati) 
\bibitem{utrace} 
Патчи utrace (http://people.redhat.com/roland/utrace/)

\end{thebibliography}
