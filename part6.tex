
\bigskip
\subsection{Предлагаемый подход}

Предлагаемый подход заключается в создании 
модуля ядра, который имел бы возможность наблюдать
за ходом исполнения приложения используя систему 
utrace-uprobes. Информацию о состояниях приложения
возможно получать из внешнего файла, который был 
бы подобен файлу политики SELinux, но содержал бы
лишь необходимую информацию и был бы очень компактен. 
При этом предлагается не вносить никаких изменений 
в язык SELinux и использовать те конструкции, которые 
использует система динамического изменения контекста. 
При этом в ядре понадобится функция, подобная 
selinux\_setprocattr(), которая должна экспортироваться
в остальное пространство ядра, либо возможно добавление
еще одного метода в LSM, который бы эта функция 
реализовывала. Преимуществами такого подхода являются: 

\bigskip
\begin{itemize}
\item Изменения существующей архитектуры SELinux минимальны, 
необходимо лишь добавление одной функции в пространство ядра. 
\item Исчезает необходимость изменения существующих приложений
путем добавления в их код вызовов методов динамического 
изменения контекста, использование которых является спорным
с точки зрения безопасности. 
\item С использованием utrace-uprobes появляется удобный
механизм наблюдения за практически любыми событиями в 
приложении и выполнения любых действий в случае их 
возникновения, в том числе за:
	\begin{itemize}
	\item Попаданием исполнения на определенные 
	адреса в коде. 
	\item Исполнением процессом вызовов fork/execx.
	\item Системными вызовами. 
	\end{itemize}
\item Существенно повышается скорость работы из-за 
отсутствия добавления системных вызовов в пользовательские 
приложения. 
\end{itemize}

\bigskip
{\bfseries Файл, содержащий информацию о смене контекстов
приложений } 
Как уже говорилось ранее, идентификатор безопасности 
целочисленной величиной, которой ставится в соответствие 
символьное представление контекста безопасности. Для 
описания необходимости изменить контекст приложения 
при попадании исполнения на определенный адрес предлагается 
использовать следующую конструкцию: 

\bigskip
\begin{lstlisting}
context_1 context_2 addr
\end{lstlisting}

\bigskip
Данная конструкция будет объявлять, что для приложения
с контекстом context\_1 необходимо произвести смену 
контекста на context\_2 при попадании исполнения на 
инструкцию по адресу addr. При этом конфигурационный 
файл, содержащий такие предложения, довольно просто перевести
в формат, содержащий следующие структуры данных: 

\bigskip 
\begin{lstlisting} 
typedef struct dyntran_info {
	uint32_t ssid;
	uint32_t tsid; 
	long 	 bpt;
}dyntran_info_t;
\end{lstlisting}

\bigskip
Преимущества создания такого бинарного файла состоят в следующем: 
в ядро попадает информация уже в той форме, в которой 
ее удобно представлять и осуществлять все необходимые 
манипуляции. В противном же случае приходилось бы при загрузке
файла, содержащего символьную информацию производить 
массу операций связанных с определением наличия указанных
контекстов в политике. При работе модуля приходилось бы 
постоянно производить приведение целочисленных идентификаторов
к их строковму представлению и обратно. 

Получить целочисленное представление контекста 
безопасности из строкового можно при помощи 
функции 
\begin{lstlisting}
#include <sepol/policydb/services.h>

int sepol_context_to_sid(const sepol_security_context_t scontext,/*IN*/
		 size_t scontext_len,    /* IN */
		 sepol_security_id_t * out_sid); /* OUT */
\end{lstlisting}

\bigskip

Используя лексический и синтаксический разбор 
строится бинарный файл с указанной структурой. 
При этом, данная утилита тесно интегрируется 
с политикой. Стоит отметить, что создание 
конфигурационного файла, отдельного от политики
позволяет применять все изменения в нем прямо 
на ходу, без пересборки основной политики и без
перезагрузки системы. В ряде случаев это помогает 
экономить время и не останавливать работу системы.

\bigskip
Проведем несколько тестов компилятора конфигурационных
данных. Рассмотрим его на следующем файле, который 
содержит некоторую информацию о двух изменениях 
типов. 

\bigskip
\begin{lstlisting}
system_u:system_r:kernel_t system_u:object_r:security_t 080456AA
system_u:object_r:fs_t     system_u:object_r:file_t     0804234B
\end{lstlisting}

\bigskip
Если запустить в отладочном режиме 
checkpolicy и проверить идентификаторы,
соотвествующие данным строковым контекстам, 
мы обнаружим, что они равны 1,2,4 и 5. Дадим 
на вход нашему модулю данный файл. На выходе 
получим (с отадочными комментариями)

\begin{lstlisting}
Got token:system_u:system_r:kernel_t
The sid of the token is: 1
Got token:system_u:object_r:security_t
The sid of the token is: 2
Got token:080456AA
The address of the bpt is 134502058
Got token:system_u:object_r:fs_t
The sid of the token is: 4
Got token:system_u:object_r:file_t
The sid of the token is: 5
Got token:0804234B
The address of the bpt is 134488907
\end{lstlisting}

\bigskip
Очевидно, что транслятор работает 
правильно. Заметим, что он должен статически
связываться с libsepol~--- библиотекой 
работы с бинарными файлами политик. 

\bigskip
\subsection{Изменения в коде ядра}
Особенностью реализации LSM является то, 
что доступ к реализации методов безопасности 
имеет лишь код ядра, они не экспортируются для 
модулей. При этом есть некоторые функции, 
которые экспортируются из SELinux, они описаны 
в файле ./linux/security/selinux/exports.c. 
Предлагается перенести реализацию методов
изменения контекста и получения информации 
о контексте приложения из selinux/hooks.c в 
сам сервер безопасности в selinux/ss/services.c
и экспортировать их в ядро из exports.c. При этом
вместо функций, реализующих реакцию на запись 
в интерфейсы /proc/PID/ в hooks.c предлагается 
заменить заглушками, которые ничего не делают. 
Действительно, отсутствует необходимость в 
двух механизмах смены доменов приложений, 
кроме этого, было бы правильно полностью 
убрать получение информации об изменении 
доменов от самих пользовательских приложений
из ядра. Таким образом в exports.c появятся две 
новые функции 

\bigskip 
\begin{lstlisting}
int selinux_kern_getprocattr(struct task_struct *p,
		char *name,char **value)
{
	if (selinux_enabled)
		return security_kern_getprocattr(p,name,value);
	else {
		*value = NULL;
		return 0;
	}
}
EXPORT_SYMBOL_GPL(selinux_kern_getprocattr);

int selinux_kern_setprocattr(struct task_struct *p, 
		char *name, void *value, size_t size)
{
	if (selinux_enabled)
		return security_kern_setprocattr(p,name,value,size);
	else {
		value = NULL;
		return 0;
	}
}
EXPORT_SYMBOL_GPL(selinux_kern_setprocattr);
\end{lstlisting} 

\bigskip 
Данные функции позволяют получать и 
изменять контекст приложения из модуля. 
